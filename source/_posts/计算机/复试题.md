---
title: 复试题
date: '2024-03-19 15:18:22'
updated: '2025-08-22 16:22:55'
---
# 易错点：
## siwtch语句不添加break
```c
    int i=1;
    switch(i){
        printf("asdasd");
        case 1:printf("ihao");
        case 2:printf("zx");
    }

```

switch语句依靠case跳转到执行地方，然后通过break跳出语句

如果不使用break则会从匹配到的case一直执行到结束，其他case下代码也会执行

## 进制表示
C语言中

八进制： 以0开头表示八进制数

十六进制：使用0x或0X作为前缀，后跟十六进制数值

二进制：使用0b或0B作为前缀

注意！ 在C语言中，移位操作‘<<'  '>>'是基于二进制数进行的，而不是针对特定进制的数

## 移位运算
移位运算符简介

在C语言中，移位运算符有双目移位运算符：<<（左移）和>>（右移）。



左移运算是将一个<font style="color:#DF2A3F;">二进制位的</font>操作数按指定移动的位数向左移动，移出位被丢弃，右边移出的空位一律补0。



右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位一律补0，或者补符号位，这由不同的机器而定。在使用补码作为机器数的机器中，正数的符号位为 0 ，负数的符号位为 1 。

<font style="color:rgb(79, 79, 79);">简单说就是：（分为 2 种）</font>

<font style="color:rgb(254, 44, 36);">1. 逻辑右移</font><font style="color:rgb(79, 79, 79);">  
</font><font style="color:rgb(79, 79, 79);">左边用0填充，右边丢弃。  
</font><font style="color:rgb(254, 44, 36);">2. 算术右移</font><font style="color:rgb(79, 79, 79);">  
</font><font style="color:rgb(79, 79, 79);">左边用原该值的符号位填充，右边丢弃。</font>

<font style="color:rgb(79, 79, 79);">到底是逻辑右移还是算术右移</font><font style="color:rgb(254, 44, 36);">取决于编译器</font>

<font style="color:rgb(254, 44, 36);"></font>

## <font style="color:rgb(254, 44, 36);">ASCII码</font>
<font style="color:rgb(77, 77, 77);">小写：</font>  
<font style="color:rgb(77, 77, 77);">a → 97</font>

<font style="color:rgb(77, 77, 77);">大写：  
</font><font style="color:rgb(77, 77, 77);">A → 65</font>

<font style="color:rgb(77, 77, 77);">数字：</font>

<font style="color:rgb(77, 77, 77);">0 ->48</font>

## <font style="color:rgb(25, 27, 31);">汇编语言程序设计第三篇——汇编程序结构</font>
+ <font style="color:rgb(25, 27, 31);">顺序结构</font>
+ <font style="color:rgb(25, 27, 31);">分支结构</font>
+ <font style="color:rgb(25, 27, 31);">循环结构</font>

# 练习题：使用文件函数实现学生成绩录入并输出
易错点：结构体使用，要记得对内部的指针进行分配内存

可改进：使用结构体数组，然后再释放结构体内存

```c
#include <stdio.h>
#include<stdlib.h>
#include<string.h>

struct Student{
    char* name;
    int score;
};
void writeToFile(struct Student *stu,char* filename,char* mode){
    FILE *fp=fopen(filename,mode);
    if((fp) == NULL){
        printf("打开文件失败");
        exit(1);
    }
    fprintf(fp,"%s %d\n",stu->name,stu->score);
    fclose(fp);

}
void readFromFile(char * filename,char* mode){
    FILE* fp=fopen(filename,mode);
    if((fp) == NULL){
        printf("打开文件失败");
        exit(1);
    }
    struct Student stu;
    stu.name=(char*)malloc(sizeof(char)*50);
    int count=1;

    while((fscanf(fp,"%s %d",stu.name,&stu.score))==2){
        printf("学生%d:%s,成绩：%d",count,stu.name,stu.score);
        count++;
    }
    fclose(fp);
}
int main(void) {
    int num;
    printf("输入学生数量：");
    scanf("%d",&num);
    printf("录入学生的成绩:\n");

    struct Student stu;
    // stu=(struct Student*)malloc(sizeof(struct Student));
    stu.name=(char*)malloc(sizeof(char)*50);
    for(int i=1;i<=num;i++){

        printf("学生%d姓名:",i);
        scanf("%s",stu.name);
        printf("学生%d成绩:",i);
        scanf("%d",&stu.score);
        writeToFile(&stu,"Student.txt","a");

    }
    printf("成绩录入\n");
    printf("读取成即\n");
    readFromFile("Student.txt", "r");
    return 0;

}

```

分块复制：

```c
#include <stdio.h>
#include<stdlib.h>
#include<string.h>
void copyFile(char* inFilename,char* outFileName,long int blockSize){
    FILE *fp1=fopen(inFilename,"rb");
    FILE *fp2=fopen(outFileName,"wb");
    
    if(fp1==NULL||fp2==NULL){
        fprintf(stderr,"未打开文件");
        exit(EXIT_FAILURE);
    }

    char buffer[blockSize];
    fseek(fp1, 0,2);
    long int Allbytes=ftell(fp1);
    fseek(fp1, 0,0);

    long int curr_bytes;
    long int totalRead=0;
    while((curr_bytes=fread(buffer,1,sizeof(buffer),fp1))>0){
        if(curr_bytes<blockSize){
            for(long int i=curr_bytes;i<blockSize;i++){
                buffer[i]=0;
            }
        }
        
        fwrite(buffer,1,sizeof(buffer),fp2);
        totalRead+=curr_bytes;
        printf("已复制%ld字节/%ld字节",totalRead,Allbytes);

        if(feof(fp1)){
            printf("到达文件末尾");

        }else if(ferror(fp1)){
            fprintf(stderr,"文件读写出错");
        }

    }

    fclose(fp1);
    fclose(fp2);


}
int main(){
     char* in="input.txt";
     char* out="output.txt";
    long int size=1024;
    copyFile(in,out,size);


}
```

# 练习：摇骰子玩游戏摆玩具
关键：初始化链表  此处应该优化为头插法

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
//使用代码完成对某学生成绩的输出
struct Node{
    int num;
    struct Node* next;
};

/*
struct Node* Initial_game(){
    struct Node*head=NULL,*temp=NULL;
    for(int i=0;i<10;i++){
        struct Node* gameobject;
        gameobject=(struct Node*)malloc(sizeof(struct Node));
        
        if(gameobject!=NULL){
            gameobject->num=(i+1);
            gameobject->next=NULL;
           
            if(head==NULL){
                head=gameobject;
                temp=head;
            }
            
            temp->next=gameobject;
           
            temp=temp->next;
        }
        else{printf("初始化失败");}
        
    }
    return head;
}
*/
struct Node* Initial_game(){
    struct Node*head=NULL,*temp=NULL;
    for(int i=10;i>=1;--){
        temp=(struct Node*)malloc(sizeof(struct Node));
        temp->num=i;
        temp->next=head;
        head=temp;
    }
    return head;
}

void playGame(struct Node**head,int n){
    struct Node*temp,*prior=NULL;
    temp=*head;
    /*
    for(int i=0;i<10;i++){
        if(temp->num==n) break;
        prior=temp;
        temp=temp->next;
    }
      if(temp==*head)return;//所查找的在链表第一个元素
    
    prior->next=temp->next;
    temp->next=*head;
    *head=temp;
  
    */
    //改进
    while(temp!=NULL){
        if(temp->num==n){
            if(prior!=NULL){
                prior->next=temp->next;
                temp->next=*head;
                *head=temp;
            }
            break;
        }
        prior=temp;
        temp=temp->next;
    }
    
}
void print_num(struct Node*head){
    struct Node*t;
    t=head;
    for(int i=0;i<9;i++){
        printf("%d-",t->num);
        t=t->next;
    }
    
    printf("%d\n",t->num);
}


int main(){
    struct Node*head=NULL;
    head=Initial_game();

    int times;
    scanf("%d",&times);
    
    for(int j=0;j<times;j++){
        int number;
        scanf("%d",&number);
        playGame(&head,number);
        print_num(head);
    }


    //释放内存分配
    struct Node*current=head;
    while(current!=NULL){
        struct Node*temp;
        temp=current;
        current=current->next;
        free(temp);
    }
    
    
}
```





# 练习题：匹配字串
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int PiPei(char* str1, char * str2) {
    int p = 0;
    int i = 0;
    while (p < strlen(str1) - 1) {
  //printf("%s",str2);
        if (strncmp(str1 + p, str2,2) == 0) {
            i++;
            p += 2;
          
        } else {
            p++;
        }
    }
    return i;
}

int main() {
    char* a;
    char b[3];
    printf("输入字符串：");
    scanf("%ms", &a);
    getchar();
    printf("输入字符串2:");
    scanf("%c%c", &b[0], &b[1]);
    b[2]= '\0';
    int result = PiPei(a, b);
    printf("%d", result);
}
```



# 复试题：读取文件，统计出现的单词以及个数，要求使用结构体数组实现，用strcmp判断字符串是否存在
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct word {
    char a[40];
    int counts;

} words;

int Read_word(char* w, FILE* p) {
    int tag = 0;//判断是否成功读取到字母
    int i = 0;
    while (fread(&w[i], sizeof(char), 1, p) == 1) {
        if (tag == 0) {
            if (w[i] >= 'A' && w[i] <= 'z') {
                i++;
                tag = 1;
            }

        } else if (tag == 1) {
            if (w[i] < 'A' || w[i] > 'z') {
                w[i] = '\0';
                return tag;
            }
            i++;
        }
    };
    return tag;
}
void strlwr(char* a){//由于strlwr函数只有再windows中才能使用，故此处自行定一个转校写函数
    for(;*a!='\0';a++){
        if(*a>='A'&&*a<='Z'){
            *a+=32;
        }
    }
}
void SearchAndAdd(char* w, struct word words[]) {
    strlwr(w);
    //words【0】。counts存储的是已经存储的单词个数
    int i = words[0].counts;  
    while (i) { //检测单词存在否
        if (strcmp(words[i].a, w) == 0) {
            printf("%s\n",w);
            words[i].counts++;
            return;
        }
        i--;
    }
    //添加单词
    strcpy(words[words[0].counts + 1].a, w);
    words[words[0].counts + 1].counts=1;
    words[0].counts++;
    printf("%s            添加单词    1211\n", words[words[0].counts].a);
}
int main() {
    FILE* p;
    p = fopen("English.txt", "r");
    if (p == NULL) {
        printf("打开文件失败");
        exit(1);
    }

    struct word words[100] = {{"", 0}};//初始化结构体数组

    char w[50];
    while (feof(p) != 1) {
        if (Read_word(w, p) == 1) {
            SearchAndAdd(w, words);
        }
    }

    printf("单词数量：%d\n", words[0].counts);
    for (int i = 1; i <= words[0].counts; i++) {

        printf("单词%s在文件中的出现次数:%d\n", words[i].a, words[i].counts);
    }
}

```





# 复试题：冒泡排序、折半查找、结构体数组
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Student {
    char name[30];
    int id;
    int score;
};
void bubbleSort(struct Student* stus, int n) {//冒泡排序
    int haveSorted;
    struct Student temp;
    do {
        haveSorted = 0;
        for (int i = 0; i < n - 1; i++) {

            if (stus[i].score > stus[i + 1].score) {
                temp = stus[i];
                stus[i] = stus[i + 1];
                stus[i + 1] = temp;
                haveSorted = 1;
            }
        }
        // printf("%d",haveSorted);
    } while (haveSorted == 1);
}

int  binarySearch(struct Student *stus,int x,int n){//基本折半查找
    int low=0;
    int high=n-1;
    int found=0;
    while(low<=high){
        int mid=(high+low)/2;
        if(stus[mid].score==x){
            return mid;
        }
        if(stus[mid].score>x){
            high=mid-1;
        }
        else {
            low=mid+1;
        }
    }
    return -1;;
}


int main() {
    struct Student Students[50] = {{"asd", 45, 40},
                                   {"wec", 45, 4},
                                   {"dxcfed", 45, 20},
                                   {"xert", 45, 90},
                                   {"iov", 45, 8}};
    int n = 5;
    /*
     for (int i = 0; i < 5; i++) {
         printf("学生姓名:");scanf("%s",Students[i].name);
         printf("\n学生ID:");scanf("%d",&Students[i].id);
         printf("\n学生成绩:");scanf("%d",&Students[i].score);

         n++;
     }
     printf("%d",n);
     */
    bubbleSort(Students, n);

    for (int i = 0; i < n; i++) {

        printf("%d ", Students[i].score);
    }
    int t=binarySearch(Students, 90, 5);
    printf("\n%d",Students[t].score);
    return 0;
}

```

# 复试题：逆序构建双向链表
弄清楚指针分配内存和直接声明结构体的区别

指针分配内存是在堆区

不能在循环内声明结构体，否则每次循环迭代时，node都会重新分配内存并位于相同的地址上，因此在每次迭代结束时，链表中的所有节点都会指向同一个节点。这是因为局部变量在循环迭代之间不会保留其值。

使用指针分配内存

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
typedef struct Node {
    int data;
    struct Node* prior;
    struct Node *next;
}Node;
// 使用指针分配内存是分到堆区

int main(void) {
    Node *head=(Node*)malloc(sizeof(Node));//head此处作为头节点
    Node *node=NULL;
    head->next=NULL;head->prior=NULL;
    int sum;
    while(1){
        scanf("%d",&sum);
        if(sum==0)break;
        node=(Node*)malloc(sizeof(Node));
        node->data=sum;
        if(head->next==NULL){
            head->next=node;
            node->prior=head;
            node->next=NULL;
        }
        else {
            head->next->prior=node;
            node->next=head->next;
            head->next=node;
            node->prior=head;
        }
    }
    for(node=head->next;node;node=node->next){
        printf("%d   ",node->data);
    }

    free(head);
}

```

# 复试题：<font style="color:rgb(34, 34, 38);">Eratosthenes筛选求质数</font>
原理：对于小于N的整数，将<=根号N的所有素数的k倍数（k从2开始）删去，余下的就是所有素数

代码：实际上俩个循环搞定

第一个for中遍历从2到根号N的所有数

第二个for为倍数

将所有可以被除尽的数，标志置为0

剩下的标志为1的即为素数

因为按照这个理论，小于4的素数，只要删除小于等于2的素数的倍数

小于9的倍数，只要删除小于等于3的素数的倍数，其实每次循环都将i^2内的素数挑出了



```c
#include <stdio.h> 
#include <stdlib.h> 

#define N 1000 

int main(void) { 
    int i, j; 
    int prime[N+1]; 

    for(i = 2; i <= N; i++) 
        prime[i] = 1; 

    for(i = 2; i*i <= N; i++) { // 这边可以改进 
        if(prime[i] == 1) { 
            for(j = 2*i; j <= N; j++) { 
                if(j % i == 0) 
                    prime[j] = 0; 
            } 
        } 
    } 

    for(i = 2; i < N; i++) { 
        if(prime[i] == 1) { 
            printf("%4d ", i); 
            if(i % 16 == 0) 
                printf("\n"); 
        } 
    } 

    printf("\n"); 

    return 0; 
}
```

# 复试题：快速排序
```c
void QuickSort(int *arr,int low,int high){
		if(low<high){//不加这个条件会死循环 
    		int i=low;
    		int j=high;
    		int key=arr[low];
    		while(i<j){
    			while(i<j&&arr[j]>=key)
    				j--;
    			if(i<j) 
    				arr[i++]=arr[j];//先赋值在自增 
    			while(i<j&&arr[i]<key)
    				i++;
    			if(i<j)
    				arr[j--]=arr[i];//先赋值在自增				
    		}
    		arr[i]=key;
    		QuickSort(arr,low,i-1);//给左边排序 
    		QuickSort(arr,i+1,high);//给右边排序 
	   }
	}
	

```

## 快排寻找第K小：
实际上在每次快排找到排序好的元素位置时，比较其下标与K的大小关系，决定是否进行下次快排

```c
#include <stdio.h>

int QuickSort_K(int* arr, int low, int high, int k) {
    do {

         //不加这个条件会死循环
            int i = low;
            int j = high;
            int key = arr[low];
            while (i < j) {
                while (i < j && arr[j] >= key)
                    j--;
                if (i < j)
                    arr[i++] = arr[j]; //先赋值在自增
                while (i < j && arr[i] < key)
                    i++;
                if (i < j)
                    arr[j--] = arr[i]; //先赋值在自增
            }
            arr[i] = key;
            if (i == k)
                return key;
            if (i < k)
                low = i + 1; //给右边排序
            if (i > k)
                high = i - 1; //给左边排序
        
    }while(low<high);
   return -1;
}

int main() {
    int a[] = {1, 5, 2, 6, 0, 3, 5, 2, 3, 5};
    int t = QuickSort(a, 0, 9, 4);
    printf("%d\n   ", t);
    for (int i = 0; i < 10; i++) {
        printf("%d   ", a[i]);
    }
}
```

考试教材参考代码：

```c

```

# 复试题：链表逆序
头插法：

```c
void Reverse(LNode*head){
    LNode* p=head->next;
    LNode*q;
    head->next=NULL;
    while(p!=NULL){
        q=p->next;;
        p->next=head->next;
        head->next=p;
        p=q;
    }
}
        
```

# 复试题：
C语言单词类型（语法符号）

标识符、运算符、分隔符、常量、注释符

C的存储类型关键字

auto、extern、register、static

C提高效率的方法

# 复试题：链表基本操作
```c
#include <stdlib.h>
#include <stdio.h>
typedef struct Node{
    int num;
    struct Node* next;
}*pt_node,Node;
void Insert(pt_node head,int e){
    Node* p=head->next;
    while(p){
        if(p->num==e)
            return;
        p=p->next;
    }
    Node* temp=(Node*)malloc(sizeof(Node));
    temp->num=e;
    temp->next=head->next;
    head->next=temp;
}
void delete(pt_node head,int e){
    Node* p=head;
    while(p->next!=NULL){
        if(p->next->num==e){
            Node* t=p->next;
            p->next=t->next;
            t->next=t;
            free(t);
        }
        p=p->next;
    }
}
Node* search(pt_node head,int e){
    Node* p=head;
    while(p->next!=NULL){
        if(p->next->num==e){
             Node*t=p->next;
             return t;
        }
        p=p->next;
    }
    return NULL;
}
void JiaoJI(Node* head1,Node*head2){
    Node* p1=head1;
    Node* p2;
    while(p1->next){
        p1=p1->next;
        p2=head2;
        while(p2){
            p2=p2->next;
            if(p1->num==p2->num){
                printf("%d  ",p2->num);
                break;
            }
        }
    }
}
/*
void BinJi(Node* head1,Node*head2){
    Node*p1=head1;
    while(p1->next){
        p1=p1->next;
        p2=head;
        while(p2){
            p2=p2->next;
        }
    }
}
*/
int main(){
    Node head;
    head.next=NULL;
	Node head2;
	head2.next=NULL;
	for(int i=1;i<9;i++){
		Insert(&head,i*i);
		Insert(&head2,i*i);
	}
    JiaoJI(&head,&head2);
	
}

```

# 复试题：显示结构
```c
循环判断选择结构
int i=1;
For :  if(i<n)  goto S0;
        goto S1;
S0  :   S;
        i=i+1;
        goto For;
S1:        ..... 



for(i=1;i<n;i++)
显示结构：
S_for:
if i<n goto S_do;
goto S_exit;
S_do:
    S;
    i=i+1;
    goto S_for;
S_exit;


条件分支
if(B)s1 else s2;
```

# 复试题：约瑟夫环   问题
题目描述

n个人围成一圈，从第一个人开始报数,数到 m的人出列，再由下一个人重新从1开始报数，数到 m的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。或输出最后一个人的编号？

```c
int main(){
    int n,num[100];
    printf("输入人数：");
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        num[i]=i+1;
    int m=0;//淘汰的人数
    int j=0;
    int k=0;//当前报数
    while(m<n-1){
        if(num[j]!=-1){
            k++;
        }
        if(k==3){
            num[j]=-1;
            k=0;
            m++;
        }
        j++;
        if(j==n)
            j=0;
    }
    j=0;
    while(num[j]==-1)
        j++;
    printf("最后一个人的编号:%d",num[j]);
}
```

# 复试题：循环二分查找
题目：一个大小为n的数组，有序但是不知道哪个方向有序，也不知道起点在哪里

，找出数组的最小值，要求时间复杂度为O（logn）

```c
//假设数组为降序
//若起点不为0，特点为数组的最小值一定在数组起点位置的左边一位
int find_min(int arr[],int n){
    int start=0;
    int end=n-1;
    if(arr[start]>arr[end]) //数组初始为有序
        return arr[end];
    while(start<end){//若初是不为有序
        int mid=(start+end)/2;
        if(arr[mid]<arr[start])//中点在分界点左边
            start=mid;
        else if(arr[mid]>arr[start])
                end=mid-1;
        else start++;
            
    }
    return arr[start];
}
//同理，假设数组为升序
int  find_min_(int arr[],int n){
    int start=0;int end=n-1;
    if(arr[start]<arr[end])
        return arr[start];

    while(start<end){
        int mid=(start+end)/2;
        if(arr[mid]>arr[end])
            start=mid+1;
        else if(arr[mid]<arr[end])
                end=mid;
        else end--;
    }
    return arr[start];
}
    
```

