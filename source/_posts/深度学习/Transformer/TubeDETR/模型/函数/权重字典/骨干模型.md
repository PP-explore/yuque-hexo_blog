---
title: 骨干模型
date: '2025-08-05 17:34:31'
updated: '2025-08-22 17:56:02'
---




```python
def build_backbone(args):
    """构建模型的主干网络（backbone）和位置编码模块
    
    Args:
        args: 包含配置参数的对象，主要使用以下属性：
            - lr_backbone: backbone的学习率（>0表示需要训练）
            - backbone: 指定backbone类型的字符串（如'timm_resnet50'）
            - dilation: 是否使用空洞卷积
            - freeze_backbone: 是否冻结backbone参数
    
    Returns:
        model: 包含backbone和位置编码的Joiner模型实例
    """
    
    # 1. 构建位置编码模块,根据args.hidden_dim=256 args.position_embedding=sine确定位置编码初始化参数 
    position_embedding = build_position_encoding(args)
    
    # 2. 判断是否需要训练backbone（学习率>0则需要训练）
    train_backbone = args.lr_backbone > 0
    
    # 3. 根据backbone类型选择不同的实现
    if args.backbone[: len("timm_")] == "timm_":
        # 3.1 使用timm库的预训练模型（如'timm_resnet50'）
        backbone = TimmBackbone(
            # 提取模型名称（去掉'timm_'前缀）
            args.backbone[len("timm_") :],  
            pretrained=False,       # 不使用预训练权重
            main_layer=-1,          # 使用最后一层的特征
            group_norm=True         # 使用Group Normalization
        )
        
    elif args.backbone in ("resnet50-gn", "resnet101-gn"):  #!!默认resnet101
        # 3.2 使用自定义的GroupNorm版ResNet
        backbone = GroupNormBackbone(
            args.backbone,          # 指定ResNet版本
            train_backbone,         # 是否训练
            False,                  # 不使用预训练
            args.dilation           # 是否使用空洞卷积
        )
    else:
        # 3.3 标准ResNet或其他backbone
        backbone = Backbone(
            args.backbone,          # backbone类型（如'resnet50'）
            train_backbone,         # 是否训练
            False,                  # 不使用预训练
            args.dilation           # 是否使用空洞卷积
        )
    
    # 4. 将backbone和位置编码组合成完整模型
    model = Joiner(backbone, position_embedding)
    
    # 5. 处理参数冻结（如果配置需要）
    if args.freeze_backbone:
        for p in model.parameters():
            p.requires_grad_(False)  # 冻结所有参数
    
    # 6. 记录backbone的输出通道数（用于后续模块构建）
    model.num_channels = backbone.num_channels
    
    return model
```

### position_encoding.py 
#### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">d_model 超参数是什么</font>
#### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">位置编码 1D正弦公式（原版Transformer）</font>
<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">对于位置</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">和维度</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">i</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>

![](/images/77c22ee3ba4e279b45e863cc56d56312.png)

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">设计意图</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">不同频率的正弦/余弦组合 → 可学习相对位置关系</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">指数衰减的频率 → 低维度高频变化，高维度低频变化</font>
    - **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键特性</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：相邻两个维度（</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2i</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 和 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2i+1</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">）共享相同的频率但相位不同。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">在位置编码中：</font>

```plain
sin(pos / frequency_factor)
```

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">frequency_factor越大 → 波形越平缓（低频）</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">frequency_factor越小 → 波形越震荡（高频）</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">所以产生的实际效果是：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">低维度（frequency_factor小的位置）→ 高频特征（快速变化）</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">高维度（frequency_factor大的位置）→ 低频特征（缓慢变化）</font>

#### **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2D扩展（本代码的实现）</font>**
<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">对图像的高（y）和宽（x）分别计算：</font>

![](/images/2f65c7065b8e32f8542bcc9cced59507.png)

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">最后拼接得到 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">PE = [PE_y; PE_x]</font>`

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">这里 dmodel是一个方向上的表征的维度大小,也就是 实际hidden_dim/2</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">然后i为 dmodel/2 即为64</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">实现中频率因子此处//2</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键作用在于实现</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">维度交替的频率缩放</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。具体原理：</font>

```python
# 计算位置编码的频率因子
dim_t = torch.arange(self.num_pos_feats, dtype=torch.float32, device=x.device)
dim_t = self.temperature ** (2 * (dim_t // 2) / self.num_pos_feats)
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">分解来看：</font>

1. `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">dim_t // 2</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：对每个索引进行整数除法</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如[0,1,2,3]变为[0,0,1,1]</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">这样做的目的是让相邻两个位置共享相同的频率（后面会解释为什么）</font>
2. `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2 * (dim_t // 2) / self.num_pos_feats</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">将上述结果映射到[0,2]区间</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如对于num_pos_feats=4：[0,0,1,1] → [0,0,0.5,0.5]</font>
3. `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">self.temperature ** ...</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">应用指数变换，</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">temperature</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">通常设为10000或100</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">这会产生一组按指数规律递减的值</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如对于temperature=100：[100^0, 100^0, 100^0.5, 100^0.5] = [1,1,10,10]  这里导致1/因子  是递减的值</font>
1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">频率交替模式</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">在Transformer的原始位置编码中，相邻维度使用相同的频率</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如：维度0和1使用频率1，维度2和3使用频率2，依此类推</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">//2</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 实现了这种成对分组</font>
1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">数学表达</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>

```plain

# 假设 num_pos_feats=4
dim_t = [0, 1, 2, 3]
dim_t // 2 = [0, 0, 1, 1]  # 整数除法
```

2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">温度缩放</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>

```python
self.temperature ** (2 * (dim_t // 2) / self.num_pos_feats)
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">计算后得到的分母序列会是类似：</font>

```python
[10000^(0/64), 10000^(0/64), 10000^(2/64), 10000^(2/64),
 10000^(4/64), 10000^(4/64), ...]
```

```python

pos_x = x_embed[:, :, :, None] / dim_t  # [batch, H, W, num_pos_feats]  广播规则
pos_y = y_embed[:, :, :, None] / dim_t

# 交替应用sin/cos
pos_x = torch.stack(
    (pos_x[:, :, :, 0::2].sin(), pos_x[:, :, :, 1::2].cos()), dim=4
).flatten(3)
pos_y = torch.stack(
    (pos_y[:, :, :, 0::2].sin(), pos_y[:, :, :, 1::2].cos()), dim=4
).flatten(3)
pos = torch.cat((pos_y, pos_x), dim=3).permute(0, 3, 1, 2)
```

pos_x变为  [batch,h,w,num_pos_feats]  其中维度3每一束都被除以 dim_t   

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">**</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">0::2</font>`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：选取所有</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">偶数索引**的通道（0, 2, 4, ...），并对它们应用</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">sin</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">**</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">1::2</font>`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：选取所有</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">奇数索引**的通道（1, 3, 5, ...），并对它们应用 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">cos</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>

`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">torch.stack(..., dim=4)</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">**</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">将</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">sin</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">和</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">cos</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">的结果堆叠成一个新的维度（</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">dim=4</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">）。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如：</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos_x[:, :, :, 0::2].sin()</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">的形状是</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[B, H, W, C/2]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos_x[:, :, :, 1::2].cos()</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 的形状也是 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[B, H, W, C/2]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">torch.stack(..., dim=4)</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">后，形状变为</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[B, H, W, C/2, 2]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（新增的</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">dim=4</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">存储</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">sin</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">和</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">cos</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">的结果）。</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">flatten(3)</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">**</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">将 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">dim=3</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（通道维度）和 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">dim=4</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（sin/cos 维度）</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">展平</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">，恢复成 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[B, H, W, C]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 的形状。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">输入</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[B, H, W, C/2, 2]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">→</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">flatten(3)</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">→</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[B, H, W, C]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">这样做的目的是让</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">sin</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">和</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">cos</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">的结果</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">交替排列</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">最终 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos_x</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 的通道顺序是 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[sin_0, cos_1, sin_2, cos_3, ...]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>

`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos = torch.cat((pos_y, pos_x), dim=3)</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">**</font>

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">将 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos_y</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（垂直方向的位置编码）和 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos_x</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（水平方向的位置编码）</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">拼接</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">在通道维度（</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">dim=3</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">）。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如：</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos_y</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 的形状是 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[B, H, W, C]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos_x</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">的形状是</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[B, H, W, C]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">cat(dim=3)</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 后，形状变为 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[B, H, W, 2C]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（即 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[B, H, W, num_pos_feats * 2]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">）。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">最后相当于每一个坐标位置都有一束位置向量,且前num_pos_feats为y方向上位置编码,后 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">num_pos_feats</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 个通道是水平方向（x坐标）的位置编码</font>



**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">为什么交替使用 sin 和 cos？</font>**

+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">这样可以让相邻的通道（如</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">C_i</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">和</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">C_{i+1}</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">）具有不同的相位（一个 sin，一个 cos），避免位置编码过于单调。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">这种设计源自 Transformer 的原始论文（Vaswani et al., 2017），目的是让模型能更好地学习相对位置关系。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如*</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 和 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos + k</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 是不同位置的两束完整向量</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：  
</font>****<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">每束向量独立编码自己的绝对位置，但通过共享频率因子和交替</font>**`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">sin/cos</font>**`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">的设计，</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">两束向量之间可以计算相对位置**。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">同一束向量内部的关系</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：  
</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">每个位置的一束向量中，相邻维度（如</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2i</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">和</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2i+1</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">）共享相同的频率</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">f_i</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">，但分别用</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">sin</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">和</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">cos</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">，这是为了后续的线性组合（见下文）。</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 相对位置如何计算？关键公式</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">当模型需要计算位置</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">和</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pos + k</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">的关系时（例如在自注意力中），会用到以下性质：</font>

```plain

# 对于同一频率f_i的两个维度：
PE(pos, 2i)     = sin(pos / f_i)    # 第2i维
PE(pos, 2i+1)   = cos(pos / f_i)    # 第2i+1维

PE(pos + k, 2i) = sin((pos + k)/f_i) 
                = sin(pos/f_i)cos(k/f_i) + cos(pos/f_i)sin(k/f_i)  # 和角公式
                = PE(pos, 2i) * PE(k, 2i+1) + PE(pos, 2i+1) * PE(k, 2i)
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">这意味着：</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">相对位置</font>**`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">k</font>**`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">的信息可以通过同一频率下的</font>**`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">sin</font>**`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">和</font>**`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">cos</font>**`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">维度线性组合得到</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

## <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">Backbone.py:</font>
```python
    # Backbone
    parser.add_argument(
        "--backbone",
        default="resnet101",
        type=str,
        help="Name of the convolutional backbone to use such as resnet50 resnet101 timm_tf_efficientnet_b3_ns",
    )

    parser.add_argument(
        "--dilation",
        action="store_true",
        help="If true, we replace stride with dilation in the last convolutional block (DC5)",
    )
#定义了一个名为dilation的命令行参数，它是一个标志参数（flag），当存在该参数时，将启用空洞卷积（dilation convolution）而不是普通卷积。该参数用于控制是否在卷积背景的最后一个卷积块中使用空洞卷积。

    parser.add_argument(
        "--position_embedding",
        default="sine",
        type=str,
        choices=("sine", "learned"),
        help="Type of positional embedding to use on top of the image features",
    )
```

#### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">空洞卷积:</font>
<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">空洞卷积（Dilated Convolution，也称为膨胀卷积或扩张卷积）是卷积神经网络中一种特殊的卷积操作，它通过</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">在卷积核元素之间插入间隔（空洞）</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">来扩大感受野，同时保持分辨率不变</font>

| <font style="color:rgba(0, 0, 0, 0.9);">特性</font> | <font style="color:rgba(0, 0, 0, 0.9);">普通卷积</font> | <font style="color:rgba(0, 0, 0, 0.9);">空洞卷积(dilation=2)</font> |
| :---: | :---: | :---: |
| <font style="color:rgba(0, 0, 0, 0.9);">卷积核物理大小</font> | <font style="color:rgba(0, 0, 0, 0.9);">3x3</font> | <font style="color:rgba(0, 0, 0, 0.9);">3x3</font> |
| <font style="color:rgba(0, 0, 0, 0.9);">实际感受野</font> | <font style="color:rgba(0, 0, 0, 0.9);">3x3</font> | <font style="color:rgba(0, 0, 0, 0.9);">5x5（等效）</font> |
| <font style="color:rgba(0, 0, 0, 0.9);">输出分辨率</font> | <font style="color:rgba(0, 0, 0, 0.9);">可能减小（若stride>1）</font> | <font style="color:rgba(0, 0, 0, 0.9);">保持输入分辨率</font> |
| <font style="color:rgba(0, 0, 0, 0.9);">计算量</font> | <font style="color:rgba(0, 0, 0, 0.9);">标准计算量</font> | <font style="color:rgba(0, 0, 0, 0.9);">与普通卷积相同</font> |


1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">保持高分辨率</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：避免过早下采样丢失细节（对密集预测任务如分割/检测关键）</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">扩大感受野</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：在不增加参数量的情况下捕获更大范围上下文</font>
3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">替代池化层</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：减少信息损失</font>
4. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">不一定会提升所有任务效果</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">对小物体检测可能不利（因细节可能被跳过）</font>

##### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">空洞卷积（dilation=2, stride=1, padding=2）</font>
    - **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">实际感受野</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：5×5（等效）</font>
    - **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">物理卷积核</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：仍为3×3，但元素间有1个间隔</font>
    - **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">输出尺寸</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：5×5（因padding=2保持尺寸）</font>
    - **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">计算过程</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（以输出(2,2)位置为例）：</font>

```plain
实际参与计算的输入位置（×表示被跳过）：
[1,  ×, 3,  ×, 5]
[×,  ×, ×,  ×, ×]
[11, ×,13, ×,15]
[×,  ×, ×, ×, ×]
[21, ×,23, ×,25]

输出[2,2] = 1×1 + 3×1 + 5×1
          +11×1 +13×1 +15×1
          +21×1 +23×1 +25×1 = 117
```

        * <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">虽然计算了9个点，但这些点</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">实际分布在5×5区域</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（感受野扩大）</font>
        * **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">关键</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：输出尺寸仍为5×5！</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">空洞卷积保持分辨率的核心在于两个设计：</font>

    1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">Padding的扩展</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">  
</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">空洞卷积需要的padding量计算公式：</font>

```plain
复制
padding = dilation * (kernel_size - 1) // 2
```

        * <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">对于3×3核，dilation=2时：  
</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">padding = 2*(3-1)/2 = 2</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">  
</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">这比普通卷积的padding=1更大，确保边缘信息不被截断</font>
    2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">Stride保持为1</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">  
</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">空洞卷积通常配合</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">stride=1</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">使用，避免主动下采样</font>

| <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">机制</font> | <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">作用</font> |
| :---: | :---: |
| <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">增大padding</font> | <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">补偿空洞带来的边缘信息损失</font> |
| <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">stride=1</font> | <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">避免主动下采样</font> |
| <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">间隔采样</font> | <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">在更大感受野内计算，但不减少输出点的数量</font> |
| <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">参数量的保持</font> | <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">仍使用3x3卷积核的参数量，只是计算时"跳着看"</font> |


<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">通过这种设计，空洞卷积实现了</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">"看得更广，但看得更稀疏"</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">的效果，完美平衡了感受野和分辨率的需求。这就是它在视频处理和密集预测任务中被广泛使用的原因！</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

#### **<font style="color:#000000;">Backbone 的作用</font>**
<font style="color:#000000;">在计算机视觉任务（如目标检测、语义分割）中，</font>**<font style="color:#000000;">Backbone（主干网络）</font>**<font style="color:#000000;"> 是模型的核心部分，负责从输入图像中提取多层次的视觉特征。它的主要功能包括：</font>

+ **<font style="color:#000000;">特征提取</font>**<font style="color:#000000;">：通过卷积层逐步提取低层（边缘、纹理）到高层（物体部件、语义）的特征。</font>
+ **<font style="color:#000000;">下采样（降维）</font>**<font style="color:#000000;">：通过池化或步长卷积降低特征图的空间分辨率，同时增加通道数。</font>
+ **<font style="color:#000000;">多尺度特征输出</font>**<font style="color:#000000;">：某些 Backbone（如 ResNet）可以返回不同层级的特征图（如 </font>`<font style="color:#000000;">layer2</font>`<font style="color:#000000;">、</font>`<font style="color:#000000;">layer3</font>`<font style="color:#000000;">、</font>`<font style="color:#000000;">layer4</font>`<font style="color:#000000;">），用于处理不同大小的目标。</font>

#### 
### class TimmBackbone(nn.Module):
:::success
 这里主要就是创建timm模型,只输出最后一层特征,前向传播中提取特征保留最后一层特征  将原本的掩码下采样为最后一层特征一样的尺寸 然后封装为NestedTensor输出

:::

```python
class TimmBackbone(nn.Module):
    def __init__(self, name, return_interm_layers, main_layer=-1, group_norm=False):
        super().__init__()
         # 1. 创建timm模型
        backbone = create_model(
            name,
            pretrained=True,
            in_chans=3,
            features_only=True,
            out_indices=(1, 2, 3, 4),
        )

        # 2. 替换BatchNorm为GroupNorm（可选）
        with torch.no_grad():
            replace_bn(backbone)
        num_channels = backbone.feature_info.channels()[-1]
        
        # 3. 记录通道数和配置
        self.body = backbone
        self.num_channels = num_channels    # 输出特征图的通道数
        self.interm = return_interm_layers  # 是否返回中间层特征
        self.main_layer = main_layer        # 主输出层的索引

    def forward(self, tensor_list):
        # 1. 提取特征
        xs = self.body(tensor_list.tensors)  # 输入形状 [B, C, H, W]  通过timm模型提取多尺度特征
        
        # 2. 选择输出层
        if not self.interm:
            xs = [xs[self.main_layer]]  # 默认只返回最后一层（main_layer=-1）
        
        # 3. 封装输出（带掩码）
        out = OrderedDict()  # 创建一个有序字典来存储各层特征
        for i, x in enumerate(xs):  # 遍历每一层提取的特征图
            # 调整掩码尺寸以匹配当前特征图的空间维度
            mask = F.interpolate(tensor_list.mask[None].float(), size=x.shape[-2:]).bool()[0]
            # 将特征图和调整后的掩码封装为NestedTensor
            out[f"layer{i}"] = NestedTensor(x, mask)
        return out
```

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">参数:</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">return_interm_layers</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">**</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">类型</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 布尔值（Boolean）</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">作用</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 控制是否返回中间层的多尺度特征（而不仅仅是最后一层）。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">典型取值</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">:</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">*</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">return_interm_layers=True</font>`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：  
</font>****<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">返回的是</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">多个中间层的输出，即一个</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">特征图组列表</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（每组对应一个层级的特征图）。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如：</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[ [1,64,64,64], [1,128,32,32], [1,256,16,16] ]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（3个不同层级的特征图）</font>
+ <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">**</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">return_interm_layers=False</font>`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：  
</font>****<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">返回的是</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">单个特征图**（通常是最后一层）。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如：</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[1,256,16,16]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（仅最后1个特征图组）</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">使用场景</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">:</font>
    - **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">目标检测/分割任务</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（如Mask R-CNN）: 需要多尺度特征时设为</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">True</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>
    - **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">分类任务</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 只需最后一层特征时设为 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">False</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">。</font>

参数`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">main_layer</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">**</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">类型</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 整数（Integer）</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">默认值</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">:</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">-1</font>`
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">作用</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 当</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">return_interm_layers=False</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">时，指定返回哪个单一特征层。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">典型取值</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">:</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">-1</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 最后一层（最高语义特征，如ResNet的C5）。</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">0</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 第一层（低层特征，如边缘纹理）。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">其他索引: 对应</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">out_indices</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">中的层号。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">为什么默认是</font>****<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>**`**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">-1</font>**`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">:</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">大多数任务（如分类）更关注高层语义特征。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">最后一层通常具有最大的感受野，适合全局理解。</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">参数</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">group_norm</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">**  </font>

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">类型</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 布尔值（Boolean）</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">默认值</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">:</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">False</font>`
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">作用</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 是否将模型中的BatchNorm层替换为GroupNorm。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">何时启用</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">:</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">小批量训练（BatchNorm对小batch不稳定）。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">输入分辨率动态变化（如测试时尺寸与训练不同）。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">实现方式</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">:</font>

```python
with torch.no_grad():
    replace_bn(backbone)  # 替换BatchNorm为GroupNorm
```

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">GroupNorm的优势</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">:</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">不依赖batch统计量，按通道分组归一化。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">对batch size不敏感，适合检测/分割任务。</font>

`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">create_model</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 参数解析**：</font>

    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">features_only=True</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：只返回特征图，不包含分类头</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">out_indices=(1, 2, 3, 4)</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：指定返回哪些层的特征（对应C2/C3/C4/C5）</font>

`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">replace_bn</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">**：将模型中的所有BatchNorm替换为GroupNorm（适合小batch训练）</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">NestedTensor</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">结构</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">这是DETR系列模型中的特殊数据结构，包含两个部分：</font>

+ `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">tensors</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 实际的特征图张量，形状为</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[batch_size, channels, height, width]</font>`
+ `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">mask</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">: 对应的二进制掩码，形状为</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[batch_size, height, width]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">，其中：</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">True</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">表示填充区域(padding)</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">False</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> 表示有效区域</font>

`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">F.interpolate(tensor_list.mask[None].float(), size=x.shape[-2:])</font>`

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">输入掩码</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：原始图像级的掩码，形状</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[batch_size, H_orig, W_orig]</font>`
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">操作分解</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    1. `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[None]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：增加一个维度，变成</font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">[1, batch_size, H_orig, W_orig]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">（因为interpolate需要4D输入）</font>
    2. `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">float()</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：将bool掩码转换为float类型（插值操作需要数值类型）</font>
    3. `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">size=x.shape[-2:]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：目标尺寸设为当前特征图的高度和宽度</font>
    4. `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">bool()[0]</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：插值后转换回bool类型，并去除临时添加的维度</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">插值方法</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：默认使用双线性插值，但对于二值掩码：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">插值后会有中间值(如0.3)</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">通过</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">bool()</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">将>0的值转为True，保持掩码性质</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">class GroupNormBackbone(BackboneBase):</font>
```python
class BackboneBase(nn.Module):
    def __init__(
        self,
        backbone: nn.Module,
        train_backbone: bool,
        num_channels: int,
        return_interm_layers: bool,
    ):
        super().__init__()
        for name, parameter in backbone.named_parameters():
            if (
                not train_backbone
                or "layer2" not in name
                and "layer3" not in name
                and "layer4" not in name
            ):
                parameter.requires_grad_(False)
        if return_interm_layers:
            return_layers = {"layer1": "0", "layer2": "1", "layer3": "2", "layer4": "3"}
        else:
            return_layers = {"layer4": 0}
        self.body = IntermediateLayerGetter(backbone, return_layers=return_layers)
        self.num_channels = num_channels

    def forward(self, tensor_list):
        xs = self.body(tensor_list.tensors)
        out = OrderedDict()
        for name, x in xs.items():
            mask = F.interpolate(
                tensor_list.mask[None].float(), size=x.shape[-2:]
            ).bool()[0]
            out[name] = NestedTensor(x, mask)
        return out
class GroupNormBackbone(BackboneBase):
    """ResNet backbone with GroupNorm with 32 channels."""

    def __init__(
        self,
        name: str,
        train_backbone: bool,
        return_interm_layers: bool,
        dilation: bool,
    ):
        # 1. 名称映射配置
        name_map = {
            "resnet50-gn": (
                "resnet50",
                "/checkpoint/szagoruyko/imagenet/22014122/checkpoint.pth",
            ),
            "resnet101-gn": (
                "resnet101",
                "/checkpoint/szagoruyko/imagenet/22080524/checkpoint.pth",
            ),
        }
        # 2. 创建基础ResNet
        backbone = getattr(torchvision.models, name_map[name][0])(
            replace_stride_with_dilation=[False, False, dilation],
            pretrained=False,
            norm_layer=GroupNorm32,
        )
        # 3. 加载GN专用权重
        checkpoint = torch.load(name_map[name][1], map_location="cpu")
        state_dict = {k[7:]: p for k, p in checkpoint["model"].items()}
        backbone.load_state_dict(state_dict)
        # 4. 确定通道数  为2048
        num_channels = 512 if name_map[name][0] in ("resnet18", "resnet34") else 2048
        # 5. 初始化父类
        super().__init__(backbone, train_backbone, num_channels, return_interm_layers)
```

:::success
前向传播过程实例:

<font style="color:#000000;">当调用</font>`<font style="color:#000000;">features, pos = self.backbone(samples)</font>`<font style="color:#000000;">时</font>

![](/images/1033e49dfeaae5672c5eb7e59f7e03ce.png)

:::

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">参数3：</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">pretrained=False</font>`

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">作用</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：是否加载torchvision官方的预训练权重</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">为什么禁用</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">我们要加载专门为GroupNorm训练的权重（来自</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">name_map</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">指定的路径）</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">官方权重是用BatchNorm训练的，不兼容GroupNorm</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">参数4：</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">norm_layer=GroupNorm32</font>`

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">作用</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：替换所有BatchNorm层</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">解决小batch size下的训练不稳定问题（如视频任务通常batch size较小）</font>
+ <font style="color:rgba(0, 0, 0, 0.9);"></font>

**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">权重加载技巧</font>**  
`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">state_dict = {k[7:]: p for k, p in checkpoint["model"].items()}</font>`  
<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">处理分布式训练保存的权重（去除</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">module.</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">前缀）</font>



**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">特征提取</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>

```plain
# 输入: [batch_size, 3, 224, 224]
features = backbone(NestedTensor(images, masks))
# 输出: 
# {
#   'layer0': NestedTensor([batch_size, 2048, 7, 7], 
#
```

#### <font style="color:rgba(0, 0, 0, 0.9);">梯度冻结</font>
+ `<font style="color:rgba(0, 0, 0, 0.9);">train_backbone=False</font>`<font style="color:rgba(0, 0, 0, 0.9);">：冻结全部参数（特征提取器模式）</font>

#### <font style="color:#000000;">整体结构概览</font>
`<font style="color:#000000;">GroupNormBackbone</font>`<font style="color:#000000;"> </font><font style="color:#000000;">基于</font><font style="color:#000000;"> </font>`<font style="color:#000000;">torchvision.models.resnet101</font>`<font style="color:#000000;">，但将所有的 </font>**<font style="color:#000000;">BatchNorm (BN)</font>**<font style="color:#000000;"> 替换为 </font>**<font style="color:#000000;">GroupNorm (GN)</font>**<font style="color:#000000;">，并加载了特定的预训练权重。其核心结构如下：</font>

```plain
ResNet101-GN
├── conv1      # 初始卷积层
├── bn1        # GroupNorm (替换原BN)
├── relu
├── maxpool
├── layer1     # 3个Bottleneck块
├── layer2     # 4个Bottleneck块（下采样）
├── layer3     # 23个Bottleneck块（可选空洞卷积）
├── layer4     # 3个Bottleneck块（可选空洞卷积）
└── 输出特征图 [B, 2048, H/32, W/32]
```

<font style="color:#000000;">(1) GroupNorm 配置</font>

+ **<font style="color:#000000;">GroupNorm32</font>**<font style="color:#000000;">：将通道分为32组（</font>`<font style="color:#000000;">num_groups=32</font>`<font style="color:#000000;">），每组独立归一化。</font>

```plain
# GroupNorm32 的实现（假设输入通道为C）
norm_layer = nn.GroupNorm(num_groups=32, num_channels=C, eps=1e-5, affine=True)
```

    - **<font style="color:#000000;">对比BN</font>**<font style="color:#000000;">：BN对每个通道跨批量归一化，而GN对每组通道在单样本内归一化。</font>

<font style="color:#000000;">(2) Bottleneck 块结构</font>

<font style="color:#000000;">每个 </font>**<font style="color:#000000;">Bottleneck</font>**<font style="color:#000000;"> 的结构（以</font><font style="color:#000000;"> </font>`<font style="color:#000000;">layer3</font>`<font style="color:#000000;"> </font><font style="color:#000000;">为例）：</font>

```plain
Bottleneck(
  (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)
  (bn1): GroupNorm(32, 256, eps=1e-05, affine=True)  # 替换BN
  (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), dilation=(2, 2), bias=False)  # 空洞卷积
  (bn2): GroupNorm(32, 256, eps=1e-05, affine=True)
  (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)
  (bn3): GroupNorm(32, 1024, eps=1e-05, affine=True)
  (relu): ReLU(inplace=True)
)
```

<font style="color:#000000;">(3) 空洞卷积配置</font>

+ <font style="color:#000000;">**</font>`<font style="color:#000000;">replace_stride_with_dilation=[False, False, dilation]</font>`<font style="color:#000000;">**：</font>
    - <font style="color:#000000;">若</font><font style="color:#000000;"> </font>`<font style="color:#000000;">dilation=True</font>`<font style="color:#000000;">，</font>`<font style="color:#000000;">layer3</font>`<font style="color:#000000;"> </font><font style="color:#000000;">和</font><font style="color:#000000;"> </font>`<font style="color:#000000;">layer4</font>`<font style="color:#000000;"> </font><font style="color:#000000;">的</font><font style="color:#000000;"> </font>`<font style="color:#000000;">3x3</font>`<font style="color:#000000;"> </font><font style="color:#000000;">卷积会启用空洞卷积（</font>`<font style="color:#000000;">dilation=2</font>`<font style="color:#000000;">）。</font>
    - **<font style="color:#000000;">作用</font>**<font style="color:#000000;">：增大感受野，避免下采样丢失分辨率。</font>

  
 

### Class Joinner: **<font style="color:rgba(0, 0, 0, 0.9);">视觉特征与位置编码的融合器</font>**
```python
class Joiner(nn.Sequential):
    def __init__(self, backbone, position_embedding):
        super().__init__(backbone, position_embedding)

    def forward(self, tensor_list):
        xs = self[0](tensor_list)
        out = []
        pos = []
        for name, x in xs.items():
            out.append(x)
            # position encoding
            pos.append(self[1](x).to(x.tensors.dtype))

        return out, pos
```

<font style="color:rgba(0, 0, 0, 0.9);">它将</font>**<font style="color:rgba(0, 0, 0, 0.9);">视觉特征提取</font>**<font style="color:rgba(0, 0, 0, 0.9);">和</font>**<font style="color:rgba(0, 0, 0, 0.9);">位置编码</font>**<font style="color:rgba(0, 0, 0, 0.9);">两个核心组件集成在一起。</font>

`<font style="color:rgba(0, 0, 0, 0.9);">Joiner</font>`<font style="color:rgba(0, 0, 0, 0.9);">的核心任务：</font>  
**<font style="color:rgba(0, 0, 0, 0.9);">将输入图像转换为特征图 + 生成对应的位置编码</font>**  
<font style="color:rgba(0, 0, 0, 0.9);">相当于视觉Transformer的"预处理管道"，为后续的Transformer编码器准备视觉token和位置信息。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">继承</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">nn.Sequential</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">？</font>**  
<font style="color:rgba(0, 0, 0, 0.9);">因为处理流程是严格顺序的：先特征提取 → 后位置编码</font>

+ `<font style="color:rgba(0, 0, 0, 0.9);">nn.Sequential</font>`<font style="color:rgba(0, 0, 0, 0.9);">已实现基础的顺序执行逻辑</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">我们只需定制</font>`<font style="color:rgba(0, 0, 0, 0.9);">forward</font>`<font style="color:rgba(0, 0, 0, 0.9);">方法</font>

**<font style="color:rgba(0, 0, 0, 0.9);">Python语法糖</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>`<font style="color:rgba(0, 0, 0, 0.9);">obj(x)</font>`<font style="color:rgba(0, 0, 0, 0.9);">等价于</font>`<font style="color:rgba(0, 0, 0, 0.9);">obj.__call__(x)</font>`

+ **<font style="color:rgba(0, 0, 0, 0.9);">PyTorch的约定</font>**<font style="color:rgba(0, 0, 0, 0.9);">：所有</font>`<font style="color:rgba(0, 0, 0, 0.9);">nn.Module</font>`<font style="color:rgba(0, 0, 0, 0.9);">子类都会自动实现：</font>

```plain
class Module:
    def __call__(self, *args, **kwargs):
        # 预处理钩子
        hooks = self._forward_pre_hooks  
        # 调用forward
        result = self.forward(*args, **kwargs) 
        # 后处理钩子
        return result
```

+ **<font style="color:rgba(0, 0, 0, 0.9);">所以实际调用链</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>

```plain
self[1](x) → position_embedding.__call__(x) → position_embedding.forward(x)
```

#### <font style="color:rgba(0, 0, 0, 0.9);">数据类型对齐</font>`<font style="color:rgba(0, 0, 0, 0.9);">.to(x.tensors.dtype)</font>`
+ **<font style="color:rgba(0, 0, 0, 0.9);">为什么需要</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">位置编码器内部可能使用</font>`<font style="color:rgba(0, 0, 0, 0.9);">float32</font>`<font style="color:rgba(0, 0, 0, 0.9);">计算</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">但特征图可能是</font>`<font style="color:rgba(0, 0, 0, 0.9);">float16</font>`<font style="color:rgba(0, 0, 0, 0.9);">（混合精度训练）</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);">作用</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>

```python
# 假设：
x.tensors.dtype = torch.float16
pos_encoding = self[1](x)  # 可能是float32

# 对齐后：
pos_encoding = pos_encoding.to(torch.float16)
```

##### <font style="color:rgba(0, 0, 0, 0.9);">常见误区澄清</font>
1. **<font style="color:rgba(0, 0, 0, 0.9);">不是所有</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">self[0]</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">都指向backbone</font>**<font style="color:rgba(0, 0, 0, 0.9);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">只有在</font>`<font style="color:rgba(0, 0, 0, 0.9);">Joiner</font>`<font style="color:rgba(0, 0, 0, 0.9);">这种特定继承</font>`<font style="color:rgba(0, 0, 0, 0.9);">nn.Sequential</font>`<font style="color:rgba(0, 0, 0, 0.9);">且按顺序初始化的类中成立</font>
2. <font style="color:rgba(0, 0, 0, 0.9);">**</font>`<font style="color:rgba(0, 0, 0, 0.9);">self[0](...)</font>`<font style="color:rgba(0, 0, 0, 0.9);">不等于</font>`<font style="color:rgba(0, 0, 0, 0.9);">self[0].forward(...)</font>`<font style="color:rgba(0, 0, 0, 0.9);">**  
</font><font style="color:rgba(0, 0, 0, 0.9);">前者会触发PyTorch的完整前向流程（包括钩子和缓存），后者是直接计算</font>

