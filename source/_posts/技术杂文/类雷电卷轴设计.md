---
title: 类雷电卷轴设计
date: '2022-12-10 14:43:53'
updated: '2025-08-22 16:21:11'
---
# 一、Input System![](/images/159ddf23074d6c31dd013fb63e140c58.png)![](/images/bc514236c76250990eefab9893e860da.png)![](/images/21e390b3741cf50a7ff1c491be0410a5.png)
# 二、嵌套式画布Nested Canvases
## Canvas画布在Unity中实现的原理：
<font style="color:rgb(0, 0, 0);">The </font>[Canvas](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/UICanvas.html)<font style="color:rgb(0, 0, 0);"> is the basic component of Unity UI. It generates meshes that represent the UI Elements placed on it, regenerates the meshes when UI Elements change, and issues </font><u><font style="color:rgb(0, 0, 0);">draw calls to the GPU so that the UI is actually displayed.</font></u>

<font style="color:rgb(0, 0, 0);">Canvas 是 Unity UI 的基本组件。它生成表示放置在其上的 UI 元素的网格，当 UI 元素发生变化时重新生成网格，并发出</font><u><font style="color:rgb(0, 0, 0);">对 GPU 的调用，以便实际显示 UI</font></u><font style="color:rgb(0, 0, 0);">。</font>

<u><font style="color:rgb(0, 0, 0);">Generating these meshes can be expensive.</font></u><font style="color:rgb(0, 0, 0);"> </font><u><font style="color:rgb(0, 0, 0);">UI Elements need to be collected into batches</font></u><font style="color:rgb(0, 0, 0);"> </font><u><font style="color:rgb(0, 0, 0);">so that they’re drawn in as few draw calls as possible.</font></u><font style="color:rgb(0, 0, 0);"> Because </font><u><font style="color:rgb(0, 0, 0);">batch generation is expensive</font></u><font style="color:rgb(0, 0, 0);">, we only want to regenerate them when necessary. The issue is that, </font><u><font style="color:rgb(0, 0, 0);">when one or more elements</font></u><u><font style="color:rgb(0, 0, 0);background-color:#FADB14;"> change on a Canvas</font></u><font style="color:rgb(0, 0, 0);">, the whole Canvas has to be</font><font style="color:rgb(0, 0, 0);background-color:#FADB14;"> analyzed once again</font><font style="color:rgb(0, 0, 0);">, to </font><font style="color:rgb(0, 0, 0);background-color:#FADB14;">figure out how to optimally draw its elements</font><font style="color:rgb(0, 0, 0);">.</font>

<font style="color:rgb(0, 0, 0);">生成这些网格可能是昂贵的。需要将 UI 元素收集到批处理中，以便在尽可能少的绘制调用中绘制它们。因为批量生成是昂贵的，我们只想在必要时再生它们。问题是，</font><u><font style="color:rgb(0, 0, 0);">当画布上的一个或多个元素发生变化时，必须再次分析整个画布，以找出如何最佳地绘制其元素。</font></u>

## <font style="color:rgb(0, 0, 0);">嵌入式画布的作用：</font>
区分静态UI（StaticUI）和动态UI（DynamicUI）

![](/images/4375c28035bd81f90eee0a521ef019c2.png)

Canvas的子对象指定批处理过程。如果Canvas中某个子元素需要重新分配，则整个canvas需要重新分配。静态UI和动态UI可以存放在不同的Canvas实现分割。

通过禁用画布组件而非对象，可以避免再次启用对象时，需要重新进行顶点缓存，降低性能损耗。同时禁用Canvas不会丢弃他的顶点缓存，重新启用不会触发重建。

[Unity UI optimization tips](https://unity.com/how-to/unity-ui-optimization-tips#how-hide-canvas)   

# 三、背景卷轴
# 四、脚本执行顺序
## 加载第一个场景
+ Awake：始终在任何 Start 函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。

脚本是一个组件挂载到GameObject下，相当于是GameObject的子类，若游戏对象没有激活，则不会激活对象底下的Awake函数

+ **OnEnable：**<font style="background-color:#F5D480;">（仅在对象处于激活状态时调用</font>）在启用对象后立即调用此函数。在创建 MonoBehaviour 实例时（例如加载关卡或实例化具有脚本组件的游戏对象时）会执行此调用。

## 在第一次帧更新之前
+ Start：（只调用一次）仅当启用脚本实例后，才会在第一次帧更新之前调用 Start。

对于场景资源中的对象，在为任何脚本调用 Update 等函数之前，将在所有脚本上调用 Start 函数。当然，在游戏运行过程中实例化对象时，不能强制执行此调用。

## 更新顺序
跟踪游戏逻辑和交互、动画、摄像机位置等的时候，可以使用一些不同事件。常见方案是在 Update 函数中执行大多数任务，但是也可以使用其他函数。

+ FixedUpdate：调用 FixedUpdate 的频度常常超过 Update。如果帧率很低，可以每帧调用该函数多次；如果帧率很高，可能在帧之间完全不调用该函数。在 FixedUpdate 之后将立即进行所有物理计算和更新。在 FixedUpdate 内应用运动计算时，无需将值乘以 Time.deltaTime。这是因为 FixedUpdate 的调用基于可靠的计时器（独立于帧率）。
+ Update：每帧调用一次 Update。这是用于帧更新的主要函数。
+ LateUpdate：每帧调用一次 LateUpdate__（在 Update__ 完成后）。LateUpdate 开始时，在 Update 中执行的所有计算便已完成。LateUpdate 的常见用途是跟随第三人称摄像机。如果在 Update 内让角色移动和转向，可以在 LateUpdate 中执行所有摄像机移动和旋转计算。这样可以确保角色在摄像机跟踪其位置之前已完全移动。

## 退出时
+ OnDisable：行为被禁用或处于非活动状态时，调用此函数。

## 销毁对象时
+ OnDestroy：对象存在的最后一帧完成所有帧更新之后，调用此函数（可能应 Object.Destroy 要求或在场景关闭时销毁该对象）。

## 协程
Update 函数返回后将运行正常协程更新。协程是一个可暂停执行 (yield) 直到给定的 YieldInstruction 达到完成状态的函数。 协程的不同用法：

+ yield 在下一帧上调用所有 Update 函数后，协程将继续。
+ yield WaitForSeconds 在为帧调用所有 Update 函数后，在指定的时间延迟后继续。
+ yield WaitForFixedUpdate 在所有脚本上调用所有 FixedUpdate 后继续。如果协同程序在 FixedUpdate 之前生成，那么它会在当前帧的 FixedUpdate 之后继续运行。
+ yield WWW 在 WWW 下载完成后继续。
+ yield StartCoroutine 将协程链接起来，并会等待 MyFunc 协程先完成。

# 五、Unity系统函数
1. ref、out、params参数关键字

```csharp
ref：相当于C++引用形参。
int a=5；
void Text（ref int a）{a=10；}
条件是：ref的变量必须是已赋值的

out： 跟ref类似，但是变量不必初始化值
int a;
void text(out int a){a=20;}

params:是为动态数组而准备的，我们直接输入数组的元素就行了
void text(params int[] a){};
text(1,2,3);//调用
如果不加params,我们只能这样调用
text(new []{1,2,3});
```

2. public bool TryGetComponent (<font style="background-color:#F5D480;">out</font> T component);

       public [Component](https://docs.unity3d.com/cn/2020.3/ScriptReference/Component.html) GetComponent ();

3. 相对于GetComponent，TryGEtComponent更加安全，返回的是bool判断是否存在该组件，如无则不会执行下面语句。
4. 程序集：降低项目文件耦合度，增加编译速度

      unity资源栏下，右键中创建程序集，对放在同一程序集中的脚本归当前程序集管理。

       对于程序集中需要引用其他程序集中的脚本，则通过程序集管理文件下添加以来的程序集

5.deleget委托 ——callback回调函数

更快捷的方法：使用lambda表达式创建一个委托，使用匿名函数更快捷写一个回调函数；

![](/images/01e14f39dd98699ff6abfedbec46608d.png)

6.ScriptObject可独立于类实例的储存数据的容器，降低内存的使用量

一般用于储存不变的数据。

对于Prefab预制体如果需要重复创建相同预制体，则是深拷贝操作，则对于预制体所拥有的数据是重复创建的消耗内存的。（class是引用类型，但在深拷贝中也会被重复创建）



