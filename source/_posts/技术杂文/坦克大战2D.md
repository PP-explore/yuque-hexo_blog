---
title: 坦克大战2D
date: '2022-12-15 19:40:39'
updated: '2025-08-22 20:35:33'
categories:
  - 技术杂文
tags: null
cover: /images/custom-cover.jpg
recommend: true
---
## 一、资产导入
对于2d游戏来说

图片资产导入后需要设置纹理类型：sprite 2D/UI

对于图集（一个图片包含多个游戏物体贴图）：sprite模式选择多个（multi）

## 二、确定游戏物体尺寸
小技巧：利用cube物体为1x1米，确定tank也为1x1米

## 三、InputSystem
使用<font style="color:rgb(77, 77, 77);"> InputAction输入动作</font>

<font style="color:rgb(77, 77, 77);">Input Action Assets包含了输入动作及其关联的绑定和控制方案。 具有.inputactions文件扩展名，并以纯JSON格式存储。</font>

![](/images/3ca0dcca347d846bb817c5748afecc63.png)

GamePlay动作表中绑定按键：

Move移动使用unity自带的输入复合组件

### 通过C#的形式对InputSystem简单进行操作
Class InputAction：

这个类表示的是一种响应动作逻辑，可以绑定到多个物理输入上，这些绑定的物理输入和得到的输入值将影响同一个 InputAction 对象。该类只代表一种动作“逻辑”而不代表任何物理输入。

例如：创建的动作表会生成的接口其中函数传入的InputAction.CallbackContext 数据结构储存每个动作逻辑在每一时刻都有现在的状态阶段（Phase）

```cpp
    public interface IGamePlayActions
    {
        void OnMove(InputAction.CallbackContext context);
    }
```

每个动作逻辑在每一时刻都有现在的状态阶段（Phase），通过 Enum InputActionPhase 表示，有五种阶段。分别为：Canceled, Disabled, Performed, Started, Waiting。在 Start, Performed, Canceled 阶段会分别触发三个对应的 C# 事件

（类型为eventAction<InputAction.CallbackContext>）。



原文链接：[https://blog.csdn.net/qq_46013595/article/details/116902263](https://blog.csdn.net/qq_46013595/article/details/116902263)

[Unity 新的输入系统Input System（一）_王王王渣渣的博客-CSDN博客_unity inputsystem](https://blog.csdn.net/wangjiangrong/article/details/104020387#:~:text=%E6%AF%8F%E4%B8%AA%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AAInputAction.CallbackContext%E5%8F%82%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%80%E4%BA%9B%E4%BA%8B%E4%BB%B6%E4%BF%A1%E6%81%AF%E3%80%82%20public,void%20OnMove%28InputAction.CallbackContext%20context%29)

[Struct InputAction.CallbackContext | Package Manager UI website](https://docs.unity3d.com/Packages/com.unity.inputsystem@0.9/api/UnityEngine.InputSystem.InputAction.CallbackContext.html)

### 创建输入管理类脚本PlayerInputActions
#### 继承InputSystem动作表接口
：PlayerInput.IGamePlay

#### 继承ScriptObjectable实现编程类对象
：ScriptableObject

[CreateAssetMenu(Menuname=类名)]//在资产栏创建.asset资产脚本对象

#### 声明一个InputSystem自动创建的C#脚本类，在awake中初始化该类
#### 在OnEnable登记Gameplay动作表的回调函数
inputActions.GamePlay.SetCallbacks（this）每次增加新的动作表都要在这登记回调函数

#### 完成动作表的接口事件
接口事件传入的参数为动作逻辑当前状态

设置不同动作阶段时会激活的事件

+ 物理输入及绑定的值会影响一个InputAction对象，该类代表的仅是收到对应物理输入后产生”动作逻辑“并不真正代表任何物理输入，每个动作逻辑在每一时刻都有现在的状态阶段（Phase）。在接口事件中，我们接收到的参数就是储存该状态阶段的数据结构
+ 由于不同的物理输入值是不同的，要读取输入值用于传递给接口事件调用函数，该输入值也在inputActions.GamePlay.SetCallbacks结构体参数中，用.ReadValue<>()读取输入动作相应类型的值

#### 创建事件委托用于接口事件调用
    public event UnityAction<Vector2> onMove = delegate { };

+ 参数匹配相应输入动作的传入值类型

#### 创建启用动作表函数
禁用其他动作表并启用需要的动作表

InputActionMap类型成员函数.Enable/Disable()

#### 创建禁用所有动作表函数：即禁用InputSystem对象 inputActions.Disable();
## 玩家类
1. 通过声明一个输入管理类并挂载管理类脚本对象完成初始化
2. OnEnable中订阅输入事件
3. OnDisable中取消订阅事件
4. Start中启用动作表
5. 编写相应事件处理函数
+ 编写移动携程，取消使用update函数
+ 禁止斜向移动
6. 渲染层次：目的：解决特效与模型上下的层次关系
7. 射击功能

## 其他需要的功能
子弹：

触发器和碰撞器的使用：移动的乙方需要添加刚体组件

详情见雷电Demo的触发器使用笔记

子弹命中物体：  
函数 OnTriggerExit（Collision collision）//collision为被碰撞的的物体碰撞组件

利用不同物体的标签判断碰撞物体是什么类型：  
用switch区分不同情况

函数<font style="color:rgb(77, 77, 77);">public void SendMessage(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver);传递给被碰撞物体执行相应函数。实现死亡</font>

<font style="color:rgb(77, 77, 77);"></font>

<font style="color:rgb(77, 77, 77);">调用特效：</font>

<font style="color:rgba(0, 0, 0, 0.75);">Invoke(</font><font style="color:rgba(0, 0, 0, 0.75);">"方法名",延时时长,每次调用间隔时长</font><font style="color:rgba(0, 0, 0, 0.75);">) 方法是 Unity3D 的一种委托机制。使用简单便捷，隐藏物体或将脚本enabled 设置为false，并不会中断Invoke的执行。 </font>
