---
title: 博客构建
date: '2025-08-13 21:14:11'
updated: '2025-08-22 20:35:37'
categories:
  - 技术杂文
tags: null
cover: /images/custom-cover.jpg
recommend: true
---
:::success
**语雀 + Elog + Hexo + GitHub Actions + Vercel +主题JSimple 博客解决方案**

:::

本人使用的是语雀专业会员,不<font style="color:#262626;">支持语雀 Token 模式,所以使用的账号密码模式,由于vercel的服务在外网,语雀无法自动调用他提供的ServerlessAPI,显示网络错误.所以我采用本地自动化任务触发hook.</font>

参考教程:[https://github.com/elog-x/yuque-hexo](https://github.com/elog-x/yuque-hexo)



## 项目目录结构:
```bash
.
├── public
├── scaffolds  //Hexo模版 文件夹
├── source
├── themes
├── .elog.env // Elog用于本地调试时的环境变量配置
├── .gitignore // git忽略文件，请将.elog.env文件加入，防止密码等信息误提交
├── _config.yml  //Hexo网站的 配置 文件
├── elog.cache.json // Elog的缓存文件，用于缓存上次同步的文件
├── elog.config.js // Elog的配置文件
└── package.json   //应用程序的信息
```

## ELog配置
`<font style="color:rgb(42, 157, 143);background-color:rgba(142, 150, 170, 0.14);">elog.config.js</font>`<font style="color:rgb(42, 157, 143);background-color:rgba(142, 150, 170, 0.14);">中存在三个字段</font>

| **<font style="color:rgb(103, 103, 108);">字段</font>** | **<font style="color:rgb(103, 103, 108);">说明</font>** |
| --- | --- |
| <font style="color:rgb(60, 60, 67);">write</font> | <font style="color:rgb(60, 60, 67);">写作平台详细配置</font> |
| <font style="color:rgb(60, 60, 67);">deploy</font> | <font style="color:rgb(60, 60, 67);">部署（博客）平台详细配置</font> |
| <font style="color:rgb(60, 60, 67);">image</font> | <font style="color:rgb(60, 60, 67);">图床平台详情配置</font> |


配置详情见:

 [https://elog.1874.cool/notion/config-catalog](https://elog.1874.cool/notion/config-catalog)    

[https://www.yuque.com/1874w/yuque-hexo-template/mw0x573oiq86af2v](https://www.yuque.com/1874w/yuque-hexo-template/mw0x573oiq86af2v)



## 文档站点工具汇总
+ 写作平台：语雀
+ 文档平台：[Hexo](https://hexo.io/)
+ 博客主题：JSimple
+ 文档同步：[Elog](https://github.com/LetTTGACO/elog)
+ 部署平台：[Vercel](https://vercel.com)

## 文档站点搭建指南
### Fork模板仓库
[点击 Fork](https://github.com/elog-x/yuque-hexo/fork) 该模板仓库到个人 Github 账号仓库下并 clone 到本地。

### 安装依赖
在项目根目录下运行命令安装依赖：

```shell
npm install
```

### 新建本地调试文件
在项目根目录中复制`.elog.example.env`文件并改名为`.elog.env`，此文件将用于本地同步文档时使用。

### 配置语雀
参考[示例知识库](https://www.yuque.com/1874w/yuque-hexo-template)，选择或新建语雀文档知识库，并按照[文档提示](https://elog.1874.cool/notion/gvnxobqogetukays#login)配置语雀并获取`token login repo`。并在本地`.elog.env`中写入。

:::warning
Token 模式或者账号密码模式二选一即可，默认为账号密码模式，如果需要切换为 Token 模式，则修改`elog.config.js`中的`platform`为`yuque`

:::

```plain
# 语雀（Token方式）
YUQUE_TOKEN=获取的Token

#语雀（账号密码模式）
YUQUE_USERNAME=一般是手机号
YUQUE_PASSWORD=登录密码

# 语雀公共参数
YUQUE_LOGIN=获取的login
YUQUE_REPO=获取的repo
```

### 本地调试
在项目根目录运行同步命令：

```shell
npm run sync:local
```

### 启动 Hexo
在项目根目录运行 Hexo 启动命令，打开本地链接。

```shell
npm run server
```

## 配置 Hexo 博客
根据 [Hexo](https://hexo.io/) 文档和 [next](https://github.com/next-theme/hexo-theme-next) 主题配置文档，配置你的博客直到你满意为主，你也可以换别的主题，这里不做演示

参考官方文档: [https://hexo.io/zh-cn/docs/setup](https://hexo.io/zh-cn/docs/setup)



### 提交代码到 github
本地访问没问题直接提交所有文件到 Github 仓库即可

### 部署到 Vercel
注册 Vercel 账号并绑定 Github，在 Vercel 导入 该项目，Vercel 会自动识别出该 VitePress 项目，不需要改动，直接选择 Deploy 部署。部署完成会有一个 Vercel 临时域名，你也可以绑定自己的域名。

![](/images/2df2e6f85b7ba8d86f83a103988f08a4.png)

## 自动化同步&部署
:::warning
注意：在非国内CI/CD环境中使用账号密码模式登录语雀，例如Github  
Workflow，会导致语雀后台登录设备中出现大量美国IP，目前尚不清楚语雀是否会有安全限制措施，请谨慎使用。推荐本地同步时使用。

:::

### 检查 Github Actions 权限
在 Github 仓库的设置中找到 `Actions-General`，打开流水线写入权限`Workflow permissions`

![](/images/ea903f5672495500ba7966b348453446.png)

### 配置环境变量
在本地运行时，用的是`.elog.env`文件中定义的语雀账号信息，而在 Github Actions 时，需要提前配置环境变量。  

在 Github 仓库的设置中找到 `Secrets and variables`，新增仓库的环境变量和`.elog.env`保持一致即可

![](/images/e9c14f115e7d8239d0126515b71c0b42.png)

### 自动化部署
当在语雀中改动文档后，手动/自动触发 Github Actions流水线，会重新从语雀增量拉取文档，自动提交代码到 Github 仓库。  

Vercel 会实时监测仓库代码，当有新的提交时都会重新部署博客。如此就实现了自动化部署博客。  

整个流程的关键点就在于：如何手动/自动触发 Github Actions。  

在项目.`github/workflows/sync.yaml`中已经配置了外部 API 触发 Github Actions 事件，所以只需要调用 API 触发流水线即可。

#### 手动触发
为了方便，这里提供一个部署在 Vercel 的免费公用的[**ServerlessAPI**](https://github.com/elog-x/serverless-api)，按照文档配置好 URL 参数并浏览器访问即可触发流水线

```shell
https://serverless-api-elog.vercel.app/api/github?user=xxx&repo=xxx&event_type=deploy&token=xxx
```

#### 自动触发-语雀 webhooks
:::warning
需要语雀专业会员

:::

在语雀知识库 - 更多设置 - 消息推送中可配置语雀 webhooks，填写上面的 Vercel Serverless API。当文档更新时，语雀会调用这个API进行推送，进而触发 Github Actions

:::warning
注意：语雀是国内文档平台，调用国外Vercel 的服务可能会失败，可自行部署 API

:::

:::warning
注意：知识库配置了「自动发布」功能后，文档的 更新/发布 操作暂不会发送 webhooks

:::



## 配置定时任务
由于个人并没有服务器,也不想在本地电脑部署服务,索性直接创建一个定时触发的windows任务来触发webhook从而实现博客推送和刷新

1. 编写ps脚本

```bash
# 替换为你的实际 Webhook URL
$url = "xxxxxxxxxxxxxx"

# 调用 Webhook
$response = Invoke-RestMethod -Uri $url -Method Get
Write-Output "$(Get-Date) 同步结果: $response"

# 可选：记录日志到文件
Add-Content -Path "$PSScriptRoot\sync.log" -Value "$(Get-Date) $response"
```

2. windows搜索栏搜索任务计划程序,打开后创建一个个人计划程序文件夹,然后右键文件夹创建任务
3. 配置任务

![](/images/3f11a2e75bbeee9c904d822b0f563d8b.png)

3. 配置触发器,我选择配置多个特定时间的触发器,考虑我使用电脑的时间,这样足够保证每天都能被触发

![](/images/0b1a01c86cef7c7b60430e1f6246be95.png)

4. 配置操作:

![](/images/5bc5a7f55871e60ae36f087ef2f04a97.png)

添加参数为   -ExecutionPolicy Bypass -File "/PAth/to/sh2"

需要定义事件触发器可以参考该教程: [https://www.pcoic.com/system/windows/3328.html](https://www.pcoic.com/system/windows/3328.html)

## 主题配置
使用JSimple主题: [https://github.com/tangkunyin/hexo-theme-jsimple](https://github.com/tangkunyin/hexo-theme-jsimple/tree/main?tab=readme-ov-file)

按照github流程首先配置好相关文件

重点关注站点_config.yml, 主题_config.yml , 注意配置tag_map,依旧修改站点yaml的`theme`字段

### Hexo识别categories和tags
注意站点_config.yml配置

```javascript
#标签文件夹
tag_dir: tags
```



为了Hexo能够识别语雀文章的标签和categories,在语雀文档的开头，写一个yaml代码块，就能又漂亮又方便地配置博客文章的标题、分类、标签、封面等属性，比如：  
![](/images/553e918c76ef5485a3ce097bfc31d74f.png)

借助elog的`<font style="color:rgb(201, 222, 241);background-color:rgb(50, 50, 56);">FormatExt</font>` 自定义文档适配处理器，将这个yaml代码块解析，并与elog生成的frontmatter合并，最终生成符合halo要求的文章元数据

具体而言

在elog.config.js文件内部的`<font style="color:#000000;">deploy字段</font>`<font style="color:#000000;">里面的FrontMatter字段进行配置</font>

> <font style="color:#000000;">Front Matter 的功能就是在页面头部使用 </font>[<font style="color:#000000;">YAML</font>](https://yaml.org/)<font style="color:#000000;"> 格式配置关于页面的基础参数，这些参数往往都是应用在主题模板上所以也叫“前端参数”</font>
>

```javascript
      frontMatter: {
        enable: true,  //开启frontmatter
        include: ['categories', 'layout','tags','title', 'date', 'updated', 'recommend', 'comment','date', 'updated'],
      }, //保留特定的yaml中的参数
      formatExt: './format.js',  //配置文档处理适配器
```

<font style="color:#000000;">修改原format.js文件中使其能够识别并提取语雀文章开头的yaml代码块:</font>

```javascript
const { matterMarkdownAdapter } = require('@elog/cli');
const yaml = require('js-yaml'); // 新增 YAML 解析库

/**
 * 自定义文档处理器
 * @param {DocDetail} doc doc 的类型定义为 DocDetail
 */
const format = (doc) => {
  // 1. 提取并解析 YAML 代码块
  const yamlBlockRegex = /^```yaml\n([\s\S]*?)\n```/;
  const match = doc.body.match(yamlBlockRegex);
  
  if (match) {
    try {
      // 解析 YAML 代码块 [2](@ref)
      const customFrontmatter = yaml.load(match[1]);
      
      // 2. 合并元数据（优先级：YAML 代码块 > 默认属性）
      doc.properties = {
        ...doc.properties,          // Elog 生成的默认属性
        ...customFrontmatter,        // 语雀文档中的自定义属性
        categories: mergeCategories(doc.properties, customFrontmatter) // 特殊处理分类
      };
      
      // 3. 从正文中移除 YAML 代码块
      doc.body = doc.body.replace(match[0], '').trim();
    } catch (e) {
      console.error('YAML 解析错误:', e.message);
    }
  }

  // 4. 转换语雀特殊标记（保留原有功能）
  if (doc.body) {
    const regexTips = /:::(?<type>tips+)\n(?<content>.+)\n:::/gi;
    doc.body = doc.body.replace(regexTips, (match, type, content) => {
      return `{% note default %}\n${content}\n{% endnote %}`;
    });

    const regexNote = /:::(?<type>[a-z]+)\n(?<content>.+)\n:::/gi;
    doc.body = doc.body.replace(regexNote, (match, type, content) => {
      return `{% note ${type} %}\n${content}\n{% endnote %}`;
    });
  }
  
  return matterMarkdownAdapter(doc);
};

// 特殊处理分类合并逻辑 [11](@ref)
function mergeCategories(defaultProps, customProps) {
  const defaultCats = Array.isArray(defaultProps.categories) 
    ? defaultProps.categories 
    : [defaultProps.categories].filter(Boolean);
  
  const customCats = Array.isArray(customProps.categories) 
    ? customProps.categories 
    : [customProps.categories].filter(Boolean);
  
  return [...new Set([...defaultCats, ...customCats])];
}

module.exports = {
  format,
};
```



### layout布局
主题layout文件夹里面存储着页面布局的<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">ejs文件-- 嵌入式 JavaScript 模板</font>Hexo默认使用EJS（Embedded JavaScript）模板引擎处理.ejs文件。

如果需要修改特定布局的内容或信息,请自行查阅相关ejs文件.

代码中的<%= %>是EJS的插值语法，表示将JavaScript表达式的结果输出到HTML中：

例如:

```javascript
        <div class="post-header">
            <h2 class="post-title"><%= __('tag_total_count', site.tags.length) %></h2>
        </div>
```

<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">site.tags.length：获取标签总数（site.tags是Hexo注入的全局变量，包含所有标签数据）。  
</font>('tag_total_count', site.tags.length)：调用国际化函数`__<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">()</font>`<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">，将标签总数动态插入到翻译字符串中</font>

### <font style="color:#000000;background-color:rgba(255, 255, 255, 0);">国际化处理（i18n）</font>
:::success
配置站点config.yaml字段 language: zh-hans,为了和主题languages文件夹下中文文件名字匹配,可以按需要选择语言

:::

<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">__()是Hexo的主题国际化函数，其行为如下：</font>

<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">查找翻译键：</font>

<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">根据当前语言设置（如zh-CN），在主题的languages/目录下查找tag_total_count对应的翻译字符串。例如：</font>

```javascript
themes/主题名/languages/zh-CN.yml
tag_total_count: "共有 %d 个标签"
```

**<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">格式化输出</font>**<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">：</font>

<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">将</font>`<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">site.tags.length</font>`<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">作为参数替换到翻译字符串的占位符（</font>`<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">%d</font>`<font style="color:#000000;background-color:rgba(255, 255, 255, 0);">），生成最终文本</font>

## <font style="color:#000000;">Disqus评论系统</font>
