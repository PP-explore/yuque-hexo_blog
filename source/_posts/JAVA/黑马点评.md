---
title: 黑马点评
date: '2025-07-23 17:11:05'
updated: '2025-09-04 21:50:37'
---
 

```yaml
categories: 
  - JAVA              # 支持多级分类（数组格式）
tags:
  - JAVA
  - 后端
cover: /images/custom-cover.jpg  # 封面图绝对路径
recommend: true       # 是否推荐
```

## 项目介绍
主要完成功能为

![](/images/5539bc16f2510400584d3c6f13d381f7.png)

<font style="color:rgb(64, 62, 62);">架构图如下，前后端分离，开发完成后前后端分别部署在 Nginx 和 Tomcat 上。</font>

![](/images/4842f945f036a5b14d96b928727e437c.png)

## 项目导入
![](/images/fcf3d705d810b733cbb2aa6171d69906.png)

我采用的Java版本为JDK17

![](/images/82da093baf7c08a331c0a56a7e491f62.png)

项目编码为UTF-8

![](/images/3846518c693a173cbeb8881a86d36ed0.png)

前端项目代码已经放在了`<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">nginx-1.18.0/html</font>`

使用localhost:8080打开前端页面

后端搭建还是分3步:

1. 创建Springboot工程项目
2. pom文件导入依赖坐标
3. yml配置文件添加配置信息

整个架构就是用mybatis-plus做持久层，业务层，控制层，加上对应注解，调mp提供的api就完了，实体类这些更不用多说，按表映射成实体类。



## Postman接口测试
[黑马点评使用Apifox进行接口测试(以导入更新店铺为例、详细图解)_黑马点评项目的接口api文档-CSDN博客](https://blog.csdn.net/2301_80558092/article/details/149539580)



## Redis
Redis 的 Java 客户端很多，常用的几种：

+ Jedis
+ Lettuce
+ Spring Data Redis

Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。

**我们重点学习Spring Data Redis。**

### SpringDataRedis
`SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：[https://spring.io/projects/spring-data-redis](https://spring.io/projects/spring-data-redis)

- 提供了对不同Redis客户端的整合（Lettuce和Jedis）

- 提供了RedisTemplate统一API来操作Redis

- 支持Redis的发布订阅模型

- 支持Redis哨兵和Redis集群

- 支持基于Lettuce的响应式编程

- 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化

- 支持基于Redis的JDKCollection实现`

#### 依赖:
```plain
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

```

Spring Data Redis中提供了一个高度封装的类：**RedisTemplate**，对相关api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：

+ ValueOperations：string数据操作
+ SetOperations：set类型数据操作
+ ZSetOperations：zset类型数据操作
+ HashOperations：hash类型的数据操作
+ ListOperations：list类型的数据操作

#### 配置Redis数据源:
```plain
在application-dev.yml中添加
spring:
  redis:
    host: 192.168.150.101
    port: 6379
    password: 123321
    database: 0
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: 100ms


```

database:指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。

可以通过修改Redis配置文件来指定数据库的数量

#### 注入RedisTemplate:
```plain
@SpringBootTest
class RedisStringTests {

    @Autowired
    private RedisTemplate redisTemplate;
}

```

### 自定义序列化:
**why?**

RedisTemplate可以接收任意Object作为值写入Redis

只不过写入前会把Object序列化为字节形式，默认是采用**<font style="color:#DF2A3F;">JDK序列化</font>**，得到的结果是这样的：

![](/images/4ff4bdef5627e70a14999bf771988a41.png)缺点：

    - 可读性差
    - 内存占用较大

#### 自定义RedisTemplate的序列化方式
**<font style="color:#DF2A3F;">josn序列化</font>**

```python
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory){
        // 创建RedisTemplate对象
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        // 设置连接工厂
        template.setConnectionFactory(connectionFactory);
        // 创建JSON序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = 
            							new GenericJackson2JsonRedisSerializer();
        // 设置Key的序列化
        template.setKeySerializer(RedisSerializer.string());
        template.setHashKeySerializer(RedisSerializer.string());
        // 设置Value的序列化
        template.setValueSerializer(jsonRedisSerializer);
        template.setHashValueSerializer(jsonRedisSerializer);
        // 返回
        return template;
    }
}

```

这里采用了JSON序列化来代替默认的JDK序列化方式

#### <font style="color:#DF2A3F;">StringRedisTemplate序列化</font>方式:
统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化

这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。

省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：

```python
@Autowired
private StringRedisTemplate stringRedisTemplate;
// JSON序列化工具
private static final ObjectMapper mapper = new ObjectMapper();

@Test
void testSaveUser() throws JsonProcessingException {
    // 创建对象
    User user = new User("虎哥", 21);
    // 手动序列化
    String json = mapper.writeValueAsString(user);
    // 写入数据
    stringRedisTemplate.opsForValue().set("user:200", json);

    // 获取数据
    String jsonUser = stringRedisTemplate.opsForValue().get("user:200");
    // 手动反序列化
    User user1 = mapper.readValue(jsonUser, User.class);
    System.out.println("user1 = " + user1);
}


```

### Redis使用相关
- redis-cli：是redis提供的命令行客户端

- redis-server：是redis的服务端启动脚本

- redis-sentinel：是redis的哨兵启动脚本

配置相关的信息在conf文件操作

启动redis指令： `redis-server redis.conf`

Redis的java客户端





## mybatis-plus 使用
```plain
// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?
User user = query().eq("phone", phone).one();
```

## Token 生成
```plain
// 7.1.随机生成token，作为登录令牌
String token = UUID.randomUUID().toString( true);
```



[https://blog.csdn.net/nawenqiang/article/details/82684001](https://blog.csdn.net/nawenqiang/article/details/82684001)

## 
## 功能实现
### 基于Session实现短信验证码登录
:::success
要点:

理解tomcat中session概念

理解tomcat线程的概念

理解threadlocal概念

:::

![](/images/9231dab9ead02c97353beebfdf0df5f2.png)

发送验证码:

校验手机号----调用RegexUtil工具类判断

生成校验码  ----调用工具类<font style="color:#262626;background-color:#f2f3f7;">RandomUtil.</font>生成随机码

保存验证码到session ---这里直接是存放在传进来的参数HttpSession session中

短信验证码登录:

校验验证码----直接session提取然后和表单验证码对比

查询用户----mybatisplus查询

创建用户---mybatisplus创建

校验登录状态:

![](/images/d52ed8204bd5454e0513be46e573a964.png)

使用LoginInterceptor拦截器统一实现校验状态

前置拦截-----

从session获取user字段

判断user字段是否为null

保存user字段到ThreadLocal中

![](/images/ccca9df73d51420aad14111e7dffff54.png)

放行----user controller里面 me方法

配置MvcConfig

添加拦截器add interceptor

#### session实现登录验证存在的问题: 
多台tomcat不共享session存储空间,切换tomcat服务室会出现数据丢失问题.

 不便于之后扩展增减tomcat服务器做负载均衡

![](/images/4503190fcefe7a39a318c4f17e0f91d1.png)

### 基于redis实现共享session登录
![](/images/45ec52ad0f2cf5f122565e7818de5775.png)

![](/images/ce4596282543e408336507d7a9cb289b.png)

发送验证码sendCode:

校验手机号----调用RegexUtil工具类判断

生成校验码  ----调用工具类<font style="color:#262626;background-color:#f2f3f7;">RandomUtil.</font>生成随机码

保存验证码到redis ---使用hash结构向redis添加验证码,注意key前缀



短信验证码登录 login:

    1. 校验验证码----直接session提取然后和表单验证码对比
    2. 查询用户----mybatisplus查询
    3. 随机生成token ---UUID
    4. 批量将user字段存储在redis中
        * 将user对象转化成HashMap
        * 调用putAll**<font style="color:#DF2A3F;">批量导入</font>**kv

![](/images/c10841fbdb72a91f8dab25de9ee57d81.png)

这里StringRedisTemplete所有kv要求是string,Bean.beanToMap还能有自定义参数,将所有字段的值都转化成string![](/images/a646b864155a31e00e1d77cf75a45e58.png)

        * 有效期设置问题----token有效期因该是未操作固定时间后失效
    5. 返回token给前端,token会作为请求头里面authorize参数携带
    6. 更新token有效期----配置拦截器RefreshTokenInterceptor

拦截器会首先提取请求头携带的token然后查询是否存在该用户

拦截器默认拦截所有的站点

TODO: 这里需要考虑拦截器初始化时机,注入redisTemplate使用构造函数手动注入 ,因为拦截器类没有被添加注解让spring来初始化

这里想取到的是哈希里面的所有字段键值对,使用entries方法

![](/images/da867a2de243772a3615ff0d5634c31e.png)

再把HasMap转为UserDTO



创建用户---mybatisplus创建

校验登录状态:



## 过滤器、拦截器执行顺序


[https://blog.csdn.net/weixin_45855671/article/details/116041388](https://blog.csdn.net/weixin_45855671/article/details/116041388)





























