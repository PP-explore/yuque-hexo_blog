---
title: 黑马点评
date: '2025-07-23 17:11:05'
updated: '2025-09-08 18:11:29'
---
 

```yaml
categories: 
  - JAVA              # 支持多级分类（数组格式）
tags:
  - JAVA
  - 后端
cover: /images/custom-cover.jpg  # 封面图绝对路径
recommend: true       # 是否推荐
```

## 项目介绍
主要完成功能为

![](/images/5539bc16f2510400584d3c6f13d381f7.png)

<font style="color:rgb(64, 62, 62);">架构图如下，前后端分离，开发完成后前后端分别部署在 Nginx 和 Tomcat 上。</font>

![](/images/4842f945f036a5b14d96b928727e437c.png)

## 项目导入
![](/images/fcf3d705d810b733cbb2aa6171d69906.png)

我采用的Java版本为JDK17

![](/images/82da093baf7c08a331c0a56a7e491f62.png)

项目编码为UTF-8

![](/images/3846518c693a173cbeb8881a86d36ed0.png)

前端项目代码已经放在了`<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">nginx-1.18.0/html</font>`

使用localhost:8080打开前端页面

后端搭建还是分3步:

1. 创建Springboot工程项目
2. pom文件导入依赖坐标
3. yml配置文件添加配置信息

整个架构就是用mybatis-plus做持久层，业务层，控制层，加上对应注解，调mp提供的api就完了，实体类这些更不用多说，按表映射成实体类。



## Postman接口测试
[黑马点评使用Apifox进行接口测试(以导入更新店铺为例、详细图解)_黑马点评项目的接口api文档-CSDN博客](https://blog.csdn.net/2301_80558092/article/details/149539580)



## Redis
Redis 的 Java 客户端很多，常用的几种：

+ Jedis
+ Lettuce
+ Spring Data Redis

Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。

**我们重点学习Spring Data Redis。**

### SpringDataRedis
`SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：[https://spring.io/projects/spring-data-redis](https://spring.io/projects/spring-data-redis)

- 提供了对不同Redis客户端的整合（Lettuce和Jedis）

- 提供了RedisTemplate统一API来操作Redis

- 支持Redis的发布订阅模型

- 支持Redis哨兵和Redis集群

- 支持基于Lettuce的响应式编程

- 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化

- 支持基于Redis的JDKCollection实现`

#### 依赖:
```plain
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

```

Spring Data Redis中提供了一个高度封装的类：**RedisTemplate**，对相关api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：

+ ValueOperations：string数据操作
+ SetOperations：set类型数据操作
+ ZSetOperations：zset类型数据操作
+ HashOperations：hash类型的数据操作
+ ListOperations：list类型的数据操作

#### 配置Redis数据源:
```plain
在application-dev.yml中添加
spring:
  redis:
    host: 192.168.150.101
    port: 6379
    password: 123321
    database: 0
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: 100ms


```

database:指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。

可以通过修改Redis配置文件来指定数据库的数量

#### 注入RedisTemplate:
```plain
@SpringBootTest
class RedisStringTests {

    @Autowired
    private RedisTemplate redisTemplate;
}

```

### 自定义序列化:
**why?**

RedisTemplate可以接收任意Object作为值写入Redis

只不过写入前会把Object序列化为字节形式，默认是采用**<font style="color:#DF2A3F;">JDK序列化</font>**，得到的结果是这样的：

![](/images/4ff4bdef5627e70a14999bf771988a41.png)缺点：

    - 可读性差
    - 内存占用较大

#### 自定义RedisTemplate的序列化方式
**<font style="color:#DF2A3F;">josn序列化</font>**

```python
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory){
        // 创建RedisTemplate对象
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        // 设置连接工厂
        template.setConnectionFactory(connectionFactory);
        // 创建JSON序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = 
            							new GenericJackson2JsonRedisSerializer();
        // 设置Key的序列化
        template.setKeySerializer(RedisSerializer.string());
        template.setHashKeySerializer(RedisSerializer.string());
        // 设置Value的序列化
        template.setValueSerializer(jsonRedisSerializer);
        template.setHashValueSerializer(jsonRedisSerializer);
        // 返回
        return template;
    }
}

```

这里采用了JSON序列化来代替默认的JDK序列化方式

#### <font style="color:#DF2A3F;">StringRedisTemplate序列化</font>方式:
统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化

这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。

省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：

```python
@Autowired
private StringRedisTemplate stringRedisTemplate;
// JSON序列化工具
private static final ObjectMapper mapper = new ObjectMapper();

@Test
void testSaveUser() throws JsonProcessingException {
    // 创建对象
    User user = new User("虎哥", 21);
    // 手动序列化
    String json = mapper.writeValueAsString(user);
    // 写入数据
    stringRedisTemplate.opsForValue().set("user:200", json);

    // 获取数据
    String jsonUser = stringRedisTemplate.opsForValue().get("user:200");
    // 手动反序列化
    User user1 = mapper.readValue(jsonUser, User.class);
    System.out.println("user1 = " + user1);
}


```

### Redis使用相关
- redis-cli：是redis提供的命令行客户端

- redis-server：是redis的服务端启动脚本

- redis-sentinel：是redis的哨兵启动脚本

配置相关的信息在conf文件操作

启动redis指令： `redis-server redis.conf`

Redis的java客户端





## mybatis-plus 使用
```plain
// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?
User user = query().eq("phone", phone).one();
```

## Token 生成
```plain
// 7.1.随机生成token，作为登录令牌
String token = UUID.randomUUID().toString( true);
```



[https://blog.csdn.net/nawenqiang/article/details/82684001](https://blog.csdn.net/nawenqiang/article/details/82684001)

## 
## 功能实现
### 基于Session实现短信验证码登录
:::success
要点:

理解tomcat中session概念

理解tomcat线程的概念

理解threadlocal概念

:::

![](/images/9231dab9ead02c97353beebfdf0df5f2.png)

发送验证码:

校验手机号----调用RegexUtil工具类判断

生成校验码  ----调用工具类<font style="color:#262626;background-color:#f2f3f7;">RandomUtil.</font>生成随机码

保存验证码到session ---这里直接是存放在传进来的参数HttpSession session中

短信验证码登录:

校验验证码----直接session提取然后和表单验证码对比

查询用户----mybatisplus查询

创建用户---mybatisplus创建

校验登录状态:

![](/images/d52ed8204bd5454e0513be46e573a964.png)

使用LoginInterceptor拦截器统一实现校验状态

前置拦截-----

从session获取user字段

判断user字段是否为null

保存user字段到ThreadLocal中

![](/images/ccca9df73d51420aad14111e7dffff54.png)

放行----user controller里面 me方法

配置MvcConfig

添加拦截器add interceptor

#### session实现登录验证存在的问题: 
多台tomcat不共享session存储空间,切换tomcat服务室会出现数据丢失问题.

 不便于之后扩展增减tomcat服务器做负载均衡

![](/images/4503190fcefe7a39a318c4f17e0f91d1.png)

### 基于redis实现共享session登录
![](/images/45ec52ad0f2cf5f122565e7818de5775.png)

![](/images/ce4596282543e408336507d7a9cb289b.png)

发送验证码sendCode:

校验手机号----调用RegexUtil工具类判断

生成校验码  ----调用工具类<font style="color:#262626;background-color:#f2f3f7;">RandomUtil.</font>生成随机码

保存验证码到redis ---使用hash结构向redis添加验证码,注意key前缀



短信验证码登录 login:

    1. 校验验证码----直接session提取然后和表单验证码对比
    2. 查询用户----mybatisplus查询
    3. 随机生成token ---UUID
    4. 批量将user字段存储在redis中
        * 将user对象转化成HashMap
        * 调用putAll**<font style="color:#DF2A3F;">批量导入</font>**kv

![](/images/c10841fbdb72a91f8dab25de9ee57d81.png)

这里StringRedisTemplete所有kv要求是string,Bean.beanToMap还能有自定义参数,将所有字段的值都转化成string![](/images/a646b864155a31e00e1d77cf75a45e58.png)

        * 有效期设置问题----token有效期因该是未操作固定时间后失效
    5. 返回token给前端,token会作为请求头里面authorize参数携带
    6. 更新token有效期----配置拦截器RefreshTokenInterceptor

RefreshTokenInterceptor主要工作是查询是否有用户并保存到threadlocal中并刷新有效期

拦截器会首先提取请求头携带的token然后查询是否存在该用户。

拦截器默认拦截所有的站点。

这里需要考虑拦截器初始化时机,注入redisTemplate使用构造函数手动注入 ,因为拦截器类没有被添加注解让spring来初始化



需要取到的是哈希里面的所有字段键值对,使用entries方法

![](/images/da867a2de243772a3615ff0d5634c31e.png)

再把HasMap转为UserDTO

![](/images/143ecc04877146ec616267dd750e515d.png)

保存用户到Threadlocal

刷新token有效期

![](/images/b2dba539bc3f9c6ea6d80eccff5e278a.png)



校验登录状态:

使用LoginInterceptor拦截器统一实现拦截和校验登录,拦截器在MvConfig中优先级为1低于RefreshTokenInterceptor拦截器

此时只需要从Threadlocal中直接获取user即可

放行----user controller里面 me方法

配置MvcConfig

添加拦截器add interceptor

重点:拦截器的优化

### 过滤器、拦截器执行顺序


[https://blog.csdn.net/weixin_45855671/article/details/116041388](https://blog.csdn.net/weixin_45855671/article/details/116041388)

### 
### 缓存更新策略
缓存的使用: 降低了后端负载，提高了读写的效率，降低了响应的时间 ,代价提高了系统的维护成本，同时也带来了数据一致性问题



<font style="background-color:rgba(255, 255, 255, 0);">**内存淘汰：redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</font>

<font style="background-color:rgba(255, 255, 255, 0);">**超时剔除：当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</font>

<font style="background-color:rgba(255, 255, 255, 0);">**主动更新：我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</font>

![](/images/1f7bfd26473e1f2e0fc274a4b1d5fc99.png)

#### <font style="color:#262626;">数据库与缓存不一致解决方案</font>
解决方案:

<font style="color:rgb(197, 200, 198);background-color:rgb(29, 31, 33);">Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</font>

<font style="color:rgb(197, 200, 198);background-color:rgb(29, 31, 33);">Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</font>

<font style="color:rgb(197, 200, 198);background-color:rgb(29, 31, 33);">Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</font>

![](/images/a1388b47fe68e163e0e8bfb639f8b45b.png)

#### 人工编码方式
有三个问题需要考虑:

1. 数据库更新之后,删除缓存还是更新缓存？
+ 更新缓存：每次更新数据库都更新缓存，无效写操作较多
+ 删除缓存：更新数据库时让缓存失效，查询时再更新缓存
2. 如何保证缓存与数据库的操作的同时成功或失败？
    - 单体系统，将缓存与数据库操作放在一个事务
    - 分布式系统，利用TCC等分布式事务方案
3. 先操作缓存还是先操作数据库？
    - 先删除缓存，再操作数据库
    - 先操作数据库，再删除缓存



人工编码方式缓存更新策略三种:

##### 双写策略:
+ <font style="color:rgb(245, 240, 232);background-color:rgb(29, 31, 32);">查询：先查询缓存，如果缓存中没有，则查询数据库，并将结果写入缓存</font>
+ <font style="color:rgb(245, 240, 232);background-color:rgb(29, 31, 32);">更新：先更新数据库，然后删除缓存或者更新缓存</font>

~~更新缓存模式~~：每次更新数据库都更新缓存，无效写操作较多（不推荐使用）

> 假如我们执行上百次更新数据库操作，那么就要执行上百次写入缓存的操作，而在这期间并没有查询请求，那么这上百次写入缓存的操作就显得没有什么意义
>

 删除缓存模式：更新数据时更新数据库并删除缓存，查询时更新缓存，无效写操作较少（推荐使用）

> 当线程1在查询缓存且未命中，此时线程1查询数据，查询完准备写入缓存时，由于没有加锁线程2乘虚而入，线程2在这期间对数据库进行了更新，此时线程1将旧数据返回了，出现了脏读，这个事件发生的概率很低，因为先是需要满足缓存未命中，且在写入缓存的那段事件内有一个线程进行更新操作，缓存的查询很快，这段空隙时间很小，所以出现脏读现象的概率也很低
>
> 这种方式的不足之处：存在脏读现象，但概率较小
>

![](/images/d8ea62cabe9338702622962b5cbf35e4.png)



##### 读写穿透方案（Read/Write Through Pattern）
将读取和写入操作首先在缓存中执行，然后再传播到数据存储

1）读取穿透（Read Through）：当进行读取请求时，首先检查缓存。如果所请求的数据在缓存中找到，直接返回数据。如果缓存中没有找到数据，则将请求转发给数据存储以获取数据。获取到的数据随后存储在缓存中，然后返回给调用者。

2）写入穿透（Write Through）：当进行写入请求时，首先将数据写入缓存。缓存立即将写操作传播到数据存储，确保缓存和数据存储之间的数据保持一致。这样保证了后续的读取请求从缓存中返回更新后的数据。







